<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>真实！找大厂实习应该达到什么样的水平</title>
      <link href="/2021/11/25/ex_bat_internal/"/>
      <url>/2021/11/25/ex_bat_internal/</url>
      
        <content type="html"><![CDATA[<p>有很多小伙伴私聊问我说，想找大厂实习，应该达到什么样的编程水平才能有可能，今天也在这里聊一聊我的看法。</p><p>下面主要分为两个视角来聊聊这个事情，分别是学生视角和公司视角</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127130422.png"></p><p>首先，我们站在公司视角看看这个问题。</p><h1 id="公司视角"><a href="#公司视角" class="headerlink" title="公司视角"></a>公司视角</h1><blockquote><p>大公司为什么会招你来实习</p></blockquote><p>有没有想过，你在大学那1、2年学习的spring也好，flask也好，刷的算法题也好，做的web前端页面也好，做的app开发也好，熟悉的mysql使用也罢，这些经历对于一个大公司来讲，其实相当于0或者趋近于0，为什么这么说呢？</p><p>因为你的这些技能大多数都是在应用阶段，大厂对于一款成熟的产品来讲，是不敢轻易让一个大二学生的代码带到线上的，起码上线之前会经过层层review。因为你还没有搞透原理啊，而且大多数学生时期所做的一些开发，能够直接对口到工作上的非常少，当然少数除外，比如我来抖音的第二天就干了个需求还上线了。</p><p>那既然自身拥有的技能几乎没有用，大厂还愿意花300/400块钱一天请你来实习呢？</p><p>你进来的时候没有技能，大公司是可以接受的，因为他们相信在他们的培养和新人landing之下，<strong>以你的能力能够达到他们想要的水平</strong>，也就是能够达到打仗的基本水平，<strong>所以招你进来并不会看你当前拥有了多少技能，有多熟练写select语句、多熟练调css样式！</strong></p><p>既然不看你的这些应用技能，那看什么呢？这个问题，我们留到学生视角去讲，这个得结合学生视角的现状来说，下面我们正式回答下开头提出的为什么找你来实习这个问题：</p><p>在实习生新人landing完成之后能够打仗的背景下，原因有下。</p><p>第一：有些紧急业务团队需求非常紧急，实习生也能够landing完成之后上岗上线。</p><p>第二：大公司有自身的人才发展战略，需要这些源源不断的学生来实现，也就是愿意“培养”大学生，公司存在竞争对手比如BAT巨头互为对手，他们就会在校招生层面有抢人，这就是为什么今天腾讯白菜价能够达到40W的原因，对于一个公司的发展来讲，人才是第一重要的，宁可早点把你招过来熟悉公司，也不愿意给其他公司抢了去。</p><p>第三：300/400块钱一天，假如你实习毕业之后愿意留在这家公司，那么这家公司就省去了非常多的培养成本，这也是他们愿意的。</p><p>这三个点回答了上面那个问题，为什么要招你去实习就算你啥也会，至少我见过校招生连SQL都不太会写的同学也进了BAT这类大厂。</p><p>那么讲完大公司为什么招你去实习，我们来看看小公司为什么愿意招你去实习。</p><blockquote><p>小公司为什么会招你来实习</p></blockquote><p>小公司，体量小，一般给实习生开的工资也有150-200/天，那他们为什么愿意呢？从我本身的实习的经历来看，小公司招人的原因也可能就只有：<strong>业务发展招不到合适的社招人员，先来几个会这个技术栈的同学顶住</strong> 这个了。因为本身小公司不需要很多的技术人员，招实习生来还需要成本，所以必然是业务需要了。</p><p>小公司招聘要求也一般要求你那些会的技能，能够马上用上最好，再不行熟悉1-2个星期能顶也可以。所以小公司基本上是基于这种原因去招人了，如果你只会算法，那我觉得你面试通不过或者很难通过。</p><p>当然，体量很小的公司也一般不招实习生。</p><p>上面就是从公司视角谈了谈这个问题，下面来进入学生视角。</p><h1 id="学生视角"><a href="#学生视角" class="headerlink" title="学生视角"></a>学生视角</h1><p>首先，我们来看看公司视角留下的那个问题：既然大公司不看你当前拥有的技能，那它看什么呢？</p><blockquote><p>大公司招实习生看什么？</p></blockquote><p>先举几个例子，假如你是leader会不会让其面试通过，一位在ACM竞赛区域赛拿到冠军的同学来面试了，面试的时候算法题都是秒解，而且还提供优化思路，但是计算机体系的基础知识，比如操作系统回答的不够好。这样的情况，你大概率会给通过，还有一位同学在大学前两年独立完成了操作系统内核的实现，并将其学习经验以及代码开源在github，获得几千甚至上万star，但是在面试的时候，做算法需要给出提示情况下才能写出来。这样的情况，你大概率也会给通过。上面提到的两位同学都有在自己不足的地方被面试官问到，但是最终还是会给通过，甚至会给高评价。为什么呢？因为他们已经通过已有成就证明了自己在计算机学习上是完全没有问题的，所以给他时间在计算机其他知识上学习也完全没有问题。</p><p>从上面两个例子，我们可以总结下来：其实大厂招实习生，就是看能力，上面提到的只是学习能力，那还有沟通能力等等方面。一直相信两句话：</p><p><strong>①表达不清楚，只可能是自己没有完全掌握；</strong></p><p><strong>②自信源于自身实力；</strong></p><p>所以当你对某个点掌握理解很深刻，那么其实是不会存在面试沟通不良的情况。</p><p>那么如何证明自身是有能力的呢？</p><p>这个问题会牵扯到为什么985高校的学生在面试的时候通过率高？这是因为，他在高考的时候已经证明过自己的学习能力了，在同等条件下，当然，很难出现同等条件，我们就当无限接近的情况吧。公司会优先选择985的同学，不要觉得这不公平，假如你是老板或者leader也会这么干。</p><p>回到如何证明自身能力，其实无非就那么几种：</p><ol><li>参加一些有名的竞赛并拿到很好的名次，比如ACM、挑战杯等等</li><li>深入研究计算机领域里的知识，做一些能够体现能力的lab，比如微内核、编译器等等</li><li>连续获得国家奖学金等高难度奖学金，证明在学业方面的能力，比如成绩每科接近满分。</li><li>…..诸如此类高难度的东西</li></ol><p>所以，这也就是为什么我在<a href="https://mp.weixin.qq.com/s/uxjRvJCXbeWmq1qmB50Ytg">计算机人应该如何度过大学四年</a>一文提到的，需要专注一件事，并且要有成绩，比如大一做算法题参加比赛等等。</p><p>下面来看看怎么样才算达到了大厂实习的水平</p><blockquote><p>达到什么样的水平就可以开始面试</p></blockquote><p>这是我们本文的中心，前面都是做一些铺垫和了解，这个问题其实比较虚，那些网上教你<strong>c++学到什么程度就可以找工作了</strong>，<strong>前端到什么地步就能找到工作</strong>，其实太虚了，水平这个东西本身就是不可具体的一个概念，你说你的水平高，那怎么样才算高？是利用设计模式能够重构改善现有代码，还是算法题做到能够秒解，或者是能够有架构思维架构整个系统呢？水平二字，本身不具备可具体性、可量化性，所以这里来跟你聊聊，进入大厂实习我所需要具备的能力。</p><p>这个能力，我用一个词概括就是：<strong>深度</strong>。何为深度？<strong>深度就是你需要掌握的不仅仅是教科书式的知识</strong>，<strong>而是挖掘原理</strong>，举个简单例子：你可能掌握了C++ 的sort函数用法，了解到它是排序函数而且高效，那么现在要你手写实现一个C++的sort，如果能写出来，这就是深度。深度，顾明思议，不应该局限于应用层面的熟练，而应该注重于理论与原理的挖掘，这也就是我为什么会说：你所写的那些页面和SQL语句在大公司面试的时候一无是处。</p><p>那么如何具备深度，这里我会建议你首先打开格局，假如你无法参加ACM校队，但是你可以参加leetcode周赛啊，你也可以参加蓝桥杯等等，蓝桥杯全国一等奖含金量也不低，假如你无法理解一个网络包是如何在网络中传递的，你不妨从操作系统入手，两台计算机如何建立联系出发，从全局层面打开格局，从而不死磕某个知识点，大学第一年如果能刷完无数道的算法题，肯定会遇到形形色色的问题，这会很好的锻炼到你解决问题的能力，如果你是在校大学生，强烈建议认真阅读<a href="https://mp.weixin.qq.com/s/uxjRvJCXbeWmq1qmB50Ytg">计算机人应该如何度过大学四年</a>。所以深度这个词，应该是你按照正确的路线学习并且深挖下去，形成一套自己解决问题的方法论，而不是看着人工智能技术火了，我去搞搞深度学习，大前端火了，我去学学RN、Flutter，微服务很牛，我去用用Dubbo。市面上的新技术层出不穷，我们应该<strong>深几度，慢几步</strong>，而不是一味的追求新技术的<strong>应用</strong>，讲到这里，想你也应该突然感悟了，<strong>重点在于深度</strong>。</p><p>那么放下你手头那些低级别的应用层面的东西，去拥抱原本属于CSer的基础原理吧，这样你在面试的时候，和面试官对吹cs，他会被你的基础知识深度能力而震撼，最后给你评价：强烈建议录取。笔者当初在面试的时候，和面试官从前端的redux状态机扯到编译原理的有限自动机，后面又扯到一个播放器的状态控制等与状态转移有关的知识，双非末流本科成功拿下sp及以上offer。编译原理的基础掌握之后，对于前端也好，后端也罢，都是可以以不变，应万变。</p><p>又是谁说的编译原理在面试的时候只会问编译过程呢？多掌握一点原理，思维就能在应用层面发散，格局就能缓缓打开，如果你觉得不可思议，那么还有一个例子：缓存，你肯定了解多级缓存，那这个概念从哪里过来的呢？学过操作系统的同学可能知道CPU有多级缓存，那我们后端架构的多级缓存是不是思路相同的呢？我们组有同学在做编译系统，他也利用了多级缓存的思路，这就比较好理解了。<strong>编程思路是不变的，唯一变化的是应用场景。</strong></p><p>最后给如我一般的双非同学一点点建议：简历关很重要，我们的简历很难通过，所以大学这几年，一定要往简历上镶金，参加重要比赛也好，成绩拔尖也好，原理研究透彻也好，开源项目也好，深度技术博客也好，<strong>这都是金，你往简历上镶就好了</strong>。加油！！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不要被所谓好玩的应用所迷惑了双眼！一名优秀的CSer，从来都是会好好探究原理，从而以不变应万变，这样，进入大厂实习，本科甚至专科以上的同学都有机会，只要你踏踏实实探究原理，深入挖掘，形成自身的亮点。</p><p>最后送给阅读完的你一句我喜欢的话：<strong>“既然选择了计算机，便只顾秃头到底。”</strong></p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大厂世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清晰！一起穿梭操作系统发展史</title>
      <link href="/2021/11/25/os-history/"/>
      <url>/2021/11/25/os-history/</url>
      
        <content type="html"><![CDATA[<p>操作系统的文章写了 3-4 篇，还没有聊过操作系统的由来，操作系统的发展等话题，今天就来和你谈谈操作系统发展史。那么就一起回顾历史，展望未来！</p><p>首先，我们思考一个问题。</p><blockquote><p>为什么会有操作系统？</p></blockquote><p>在我们教科书上会提到分时系统、批处理系统等等现代操作系统前的中间产物，都也会讲到管理硬件的功能，但似乎没有讲到为什么有操作系统这个东西，诞生操作系统是为了解决什么样的问题？那下面来通俗易懂的讲讲为什么有这个东西。</p><p>假设在远古时代的计算机需要由人工进行运行操作，但是运行期间又不需要更多的人为干预，这个时候人就空闲下来了，但是<strong>计算机被这个任务占据了，啥也干不了，白白的浪费时间</strong>（程序员的工资那么高，时间这么浪费了的话，损失惨重！），而且对于计算机的核心部件 CPU 来说，并不是一直有数据可以来运行，也有对于其他部件的操作，比如 IO 操作，<strong>在等待 IO 的时间里特别漫长</strong>，这就浪费了宝贵的 CPU 资源。所以这样的计算机运行状况是非常低效的，那么操作系统解决的一个问题就是<strong>提高效率</strong>，提高 CPU 的使用率，不让 CPU 休息，疯狂压榨它！！！</p><p>同时，计算机操作人员直接操作计算机硬件的话，非常麻烦，还容易出错，所以人们总是寻求一些办法来解决现有问题，这种解决问题的方法论在哪个学科都成立，既然麻烦，那何不根据计算机领域哲学方法论：<strong>添加一个中间层来解决现有问题</strong>，那么操作系统就是这个相对于硬件的中间层。它的出现就屏蔽了底层硬件的细节，从而让出错的概率大大降低，以及让计算机操作人员更加顺风顺水的操作，程序也开始可以被操作系统自动管理。</p><p>上面提到的两个问题可以归结于三个字：<strong>自动化</strong>。 程序员总是趋向于追求自动化，比如自动化测试等等。自动化有什么好处呢？借用一句工业革命时期的话那就是：<strong>解放生产力</strong>。代替那些重复性工作</p><p>所以操作系统的出现也是可比喻成生产力的解放，使得程序运行更加高效。</p><p>既然我们知道了需要这么一个操作系统来进行自动化运行，那么什么是操作系统呢，为什么叫操作系统而不叫管理系统或者其他名字呢？</p><blockquote><p>什么是操作系统？</p></blockquote><p>操作系统的英语翻译为：Operating Systems. 翻译为操作系统，操作二字有点流水线工人操作员的意味，是不是感觉有点土。这么理解的话，那就有些许偏差了，再来一个英语词汇：Operating Surgeon. 这个词汇的意思是主刀大夫. 主刀大夫是什么人物？在整个手术室里是权威呀，说上麻药，麻醉师马上就位，说要 xx 手术刀，助理大夫马上送到，是<strong>主宰手术室一切的人物</strong>。所以<strong>操作系统也是主宰一切的系统，计算机体系世界里的一把手。</strong></p><p>那么操作系统主宰的一切，这一切包含什么呢？</p><p>当然是计算机上里发生的一切事情。在最原始的计算机并没有操作系统，而是直接由人来掌控事情，即所谓的单一控制终端、单一操作员模式。但是随着计算机复杂性的增长，人已经不能胜任直接掌控计算机了。于是我们编写出操作系统来掌控计算机，<strong>将人类从日益复杂的掌控任务中解脱出来</strong>。</p><p>所以明确的说操作系统就是 <strong>掌控计算机一切的舵主，权威至上。</strong></p><p>我们知道操作系统管理计算机的一切，那操作系统具体管理哪些东西？</p><blockquote><p>操作系统管理哪些东西？</p></blockquote><p>还是来张图更加清晰。如下图。操作系统的 4 个核心管理，当然还有其他的一些安全性等等管理。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125705.png"></p><p>如图，第一个是<strong>进程管理</strong>，管理要素包含三个：第一个是<strong>公平</strong>，即每个程序都有机会被 CPU 执行。第二个是<strong>非阻塞</strong>，任何一个程序不能无限制的阻塞 CPU 给其他程序执行。如果一个程序在运行过程中需要输入输出或者因别的什么事情而发生阻塞，这个阻塞不能妨碍其他进程继续运行。第三个是<strong>优先级</strong>，CPU 也是分优先级的，也就说优先级高的进程会首先被 CPU 执行，都优先级其次。</p><p><strong>内存管理</strong>主要是管理缓存、主存、磁盘、磁带等存储介质所形成的内存架构。为实现这一内存架构，设计了虚拟内存这一层结构，即将物理内存扩充到外部存储介质上。这样内存的空间就大大地增加了，能够运行的程序的大小也大大地增加了。内存管理的另一个目的是让很多程序 共享同一个物理内存。这就需要对物理内存进行分割和保护，不让一个程序访问另一个程序所占的内存空间。</p><p><strong>外存管理</strong>通常也称为存储管理，它也就是文件系统管理了。文件系统的主要目的是将磁盘变成一个很容 易使用的存储媒介以提供给用户使用。这样我们在访问磁盘时无须了解磁盘的物理属性或数据在磁盘上的精确位置，诸如磁道、磁柱、扇面等。当然，文件系统还可以建立在光盘和磁带上。只是使用最为频繁的文件 系统都以磁盘为介质。</p><p><strong>I/O 管理</strong>也称为设备管理，就是管理输入输出设备。I/O 管理的目的有两个：一是屏蔽不同设备的差异性，即用户用同样的方式访问不同的设备，从而降低编程的难度，你要知道目前存在有上万种 IO 设备，每个 IO 设备的适配都是在这里进行的，这是<strong>抽象和封装的魅力</strong>；二是提供并发访问，即将那些看上去并不具备共享特性的设备（如打印机等）变得可以共享。</p><p>上面三个问题，我们走进了操作系统的世界，了解了操作系统为何而来，它又在干些什么，下面还是来进入主题，操作系统历史，那么操作系统到底经历了些什么呢？老规矩：一图胜千言。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125714.png"></p><p>我们就从萌芽阶段的状态机系统来讲起。</p><h3 id="第一阶段：状态机系统"><a href="#第一阶段：状态机系统" class="headerlink" title="第一阶段：状态机系统"></a>第一阶段：状态机系统</h3><p>状态机系统是计算机在萌芽阶段出现的，也就是大概 1940 年以前。其实这种系统其实都不能算做操作系统，因为他就是一种简单的状态转换程序，通过特定的输入和特定的状态进行转换。能做的计算也非常简单，也就仅限于加减法，也不支持命令交互等等功能。当然，它有一个非常大的好处，没有安全风险，没几个人能解除到它，自然就不存在安全问题了。</p><h3 id="第二阶段：单一控制系统"><a href="#第二阶段：单一控制系统" class="headerlink" title="第二阶段：单一控制系统"></a>第二阶段：单一控制系统</h3><p>学过计算机导论的话，你应该了解计算机领域的的经典模型——冯若依曼体系结构原理，它是 1945 年左右提出的，属于这个时期，那还记得我们全世界的第一台电子计算机是什么时候出现的吗？没错，也是这个时期出现的，时间是 1946 年 2 月，诞生在美国的宾夕法尼亚大学，名称叫做 ENIAC。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125723.png"></p><p>这台电子计算机其实没有搭载所谓的操作系统，他只是提供了一些<strong>标准的命令给用户使用</strong>，这些标准的命令集就构成了原始的操作系统 SOSC（System Operation Support Center）。这些 SOSC 满足了系统运行的基本功能，<strong>提供人机交互功能</strong>，在这种情况下，任何时刻却只能做一件事，不支持并发也不支持多道程序设计。在这种系统下的资源利用率很低很低，你<strong>输入一个命令它就执行一次</strong>，类似于拨一下就动一下，但是动的拿一下又全部占用计算机。这种情况，我们可以理想成只有一个程序能运行。从机器的角度出发，时时刻刻都要等着人来操作，效率真的太低了，详细情况看看下图更清晰。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125734.png"></p><p>多个人需要使用这台计算机，指令就会断断续续，就会影响效率，就算是一个人输入多个命令，相比于计算机来讲，人输入的指令速度也会很慢。</p><p>那有没有不等人的操作让其自己执行呢？随着计算机的发展那当然有了，接下来就打破这种过于笨拙的情况，来到自动化一点的时代。</p><h3 id="第三阶段：批处理系统"><a href="#第三阶段：批处理系统" class="headerlink" title="第三阶段：批处理系统"></a>第三阶段：批处理系统</h3><p>在仔细考察了 SOSC 后，人们发现，SOSC 效率之所以低下，是因为<strong>计算机总是在等待人的下一步动作，而人的动作总是很慢</strong>。因此，人们觉得，如果去掉等待人输入命令的时间，即让所有的人先想好自己要运行的命令构成一个程序，然后列成一个清单，打印在纸带上，然后交给一个操作人员来一批一批地处理，效率不就提高了吗？这样就形成了批处理操作系统。这是又大大提高单一控制终端的操作系统 SOSC 的效率。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125742.png"></p><p>显然，在这种工作模式下，系统的功能得到了提升，必然复杂性也随之提升，在这种系统下，用户只管把程序放在磁带上，用户自己可以不在场而去干别的，接下里就是由操作员操作批处理系统来处理一个个任务，处理完了就给出结果。最早的自动化处理雏形出现了。但是这个时候也<strong>只能一个个任务处理，一个任务读取 IO 的时候 CPU 就等待下来了</strong>，还是在一定程度上会影响 CPU 运行的效率，有没有办法再提高一些呢。这个时候就抓住了 CPU 和 I/O 设备运行时串行的这点，做了文章。</p><h3 id="第四阶段：多道批处理系统"><a href="#第四阶段：多道批处理系统" class="headerlink" title="第四阶段：多道批处理系统"></a>第四阶段：多道批处理系统</h3><p>先来看看单道批处理下的 CPU 与 IO 运行关系，如图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125749.png"></p><p>当 IO 操作的时候，CPU 会等待 IO 操作的结果，结果返回后才会继续执行程序，我们可以认为这个时候程序是串行的。由于 I/O 设备的运行速度相对于 CPU 来说实在太慢，这种让<strong>高速设备等待低速设备的状况无法接受</strong>。那能不能将 CPU 和 I/O 进行并发呢？即在一个程序输入输出时，让另一个程序继续执行。换句话说，能不能将 CPU 运行和 I/O 设备的运行重叠起来而改善整个系统的呢？答案是肯定的，我们可以设计将多个程序同时加载到计算机内存里，以前内存里只有一个程序，而现在有多个程序在运行，从而就出现了多道批处理操作系统。这是一个划时代的操作系统，<strong>开始从原来串行执行任务，到并发执行任务</strong>，大大提高了 CPU 的使用率，具体如图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125757.png"></p><p>这样 CPU 就开始被任一时刻都用起来了，不会让它再次打盹了。这两个阶段都是可以为围绕如何提高 CPU 运行效率来优化。可以发现，在程序 1 要让出 CPU 的时候，那么到底是让程序 2 执行呢，还是程序 n 执行呢，这就涉及到 CPU 运行时间如何分配问题，随着发展，我们又有了分时运行的方案。</p><h3 id="第五阶段：分时系统"><a href="#第五阶段：分时系统" class="headerlink" title="第五阶段：分时系统"></a>第五阶段：分时系统</h3><p><strong>多道批处理操作系统的出现使计算机的效率（主要是吞吐率）大大提高</strong>。不过批处理系统这里有一个很大的问题，写程序的人需要交给一个计算机操作人员来执行程序，对于结果等全部执行完了之后才知道，也不能知道执行步骤，这显然也是低效且很难接受的。万一这个计算机操作人员操作失误或者忘记了呢，所以这个时候就得提出人人都可以拥有计算机的使用权，从而去考虑 CPU 资源怎么分配，这就是<strong>分时系统</strong>，给每个用户分配的时间是均等份的。即分给每个人有限的时间，只要时间到了，就换一个进程。这种时分切换下的操作系统就是分时操作系统。在这种系统下，用户就可以自己调试程序，这里就相当于有多个程序并发的在执行，<strong>只要我们将 CPU 切换的时间无限细分，那么每个用户就会感觉独自占有计算机资源一样</strong>，这样的运行模式下就是有多个程序一起执行，也就是我们现代操作系统里的<strong>进程并发</strong>概念。详细情况如图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125812.png"></p><p>A,B,C,D 四个程序依次在 CPU 上执行，如果将每等分无限细分，就好像 A,B,C,D 四个程序自己一个人独占 CPU 资源一样，这也就出现了程序执行的并发现象，这是一个假象，只是执行速度太快，人类无法感知而已。</p><p>在分时系统下，操作系统的复杂性开始大大提高，还会涉及到资源互斥、进程通信死锁、保护等问题，复杂性指数可以说是增长超快了。</p><p>那么在分时系统下，每个进程获得 CPU 的执行时间是公平的，不存在偏差，这就会导致一个问题，比如我输入单词这么一个操作，不可能等 CPU 执行权限来到了才能执行吧，得及时响应，不然的话，用户体验极其差评！所以就出现了实时系统。</p><h3 id="第六阶段：实时系统"><a href="#第六阶段：实时系统" class="headerlink" title="第六阶段：实时系统"></a>第六阶段：实时系统</h3><p>随着计算机技术的进步，产生了一种需求：<strong>有一个程序需要在需要运行的时候马上运行</strong>，而不能等到分时轮到这个进程执行，比如现在的鼠标、键盘等输入性操作，在不破坏操作系统原有运行体系下，需要响应这些事件。也就是计算机对这些事件必须在规定的事件内做出响应，这就是实时系统，详细情况如下图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127125823.png"></p><p>这个时候响应事件的优先级最高，CPU 会优先处理这些高优的事件，也就是有了实时被处理的感觉。</p><h3 id="第七阶段：现代操作系统"><a href="#第七阶段：现代操作系统" class="headerlink" title="第七阶段：现代操作系统"></a>第七阶段：现代操作系统</h3><p>1980 之后，就开始进入现代操作系统时代了，计算机工业开始迅速腾飞，出现了 DOS，Windows，MacOS 主流操作系统，总结了前面各个阶段的优缺点，发展了现代操作系统，同期也出现了 PC 机，计算机算力开始大大提高，后来又出现网络，分布式操作系统又得到了发展。</p><p>在操作系统的历史演进过程中，我们可以发现基本上是围绕如何提高 CPU 效率这个方向来进行，让 CPU 不打盹是我们的目标，围绕这个点来看计算机发展史，非常能理解当前时代出现了什么问题，如何去解决问题。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我们生活在一个最好的时代，这个时代只要你动动手就能获取你想要了解的信息。一起享受这个时代所带来的的便捷吧！</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机发展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埋头拉车的同时，也要记得抬头看路</title>
      <link href="/2021/11/22/ex-ex-copy/"/>
      <url>/2021/11/22/ex-ex-copy/</url>
      
        <content type="html"><![CDATA[<p>​你好，我是Cone。</p><p>关于我的故事想必你也有所耳闻了，今天想要和大家分享一个在我成长路上的小心得——不要沉寂在埋头拉车的疲倦中，要记得抬头看路。</p><p>想必每个人都想要掌控命运，让人生走在自己设定的轨道上。当然，我也不例外。你也可以将这类人简单地理解为：有想法的人。</p><p>刚刚进入大学，我和大多数人一样迷茫，不知所措，过完了所谓最累的高中三年，那个时候对于后面的四年会发生什么，毫无概念。不过，好在我也是一个有想法的人呐。那么我应该如何去有想法呢，应该有什么想法呢？其实这些，对于刚刚进入大一的我来说，还太难了，可以理解为：格局太小了。</p><p>有一句话</p><blockquote><p>选择大于努力<br>可能你会反驳，我就算选择了正确的道路，我不努力，那也不一样于事无补，你可能还反驳，我都不努力，哪里来的选择权。诚然，前两者都成立，不过其实这句话应该要有一个背景信息，那就是：<strong>对于一个有想法的人来说，选择大于努力。</strong></p></blockquote><p>相信你走在人生的道路上，你会越来越发现，选择大于努力。</p><p>就像我大学计算机组成原理老师讲过一个事情：20多年前，我要是跟着大学同学一起去华为做研发，现在就不用在这里教书了。（我们不去讨论两个选择的利弊，单纯的从“那个结果”导向来看，选择前者对于结果是最优解） 又像：我身边遇到过的一些人，14年他们同事来到了字节，而他们现在才来，他们就会说选择大于努力。很多例子，都在围绕“那个结果”而认证这句话。</p><p>那么就暂且这么认为这句话是成立的吧。</p><p>扯回到大一，格局小了，怎么办？按照正常的方法论：发现问题，解决问题。于是，我发现了问题：因为我根本无法知道，四年后，我会在哪里，我应该在哪里，不像高考，我要么在大学的课堂里读书，那么在流水线上搬砖。</p><p>问题的根本就在于：对四年后会怎么样一无所知。然后我就想办法开始解决问题。</p><p>解决这类未来性的问题最好的办法是什么？</p><p>当然是发挥我们的优点：<strong>参考</strong>。</p><p>你会想去哪里参考，当初我想到的，可以是本校的大三大四的学长经历分享，又或者可以是网上别人的分享。这里我选择了，本校学长们的经历参考。经历分享总归是少的。于是，我开始添加一些牛逼学长的QQ，添加QQ的目的不是为了主动发信息问他们问题，而是走进他们的QQ动态，去看看他发过哪些动态，从时间线上去确认，那个时候他的大一、大二以及大三是如何过的。印象很深刻的几位学长：</p><ul><li>有Let’s try 开发社社团创始人， 他那两次高考的经历以及大三上学期就拿到了字节跳动实习offer的经历对我的启发是非常大的，后来我成为了他技术上的徒弟，非常幸运了，后面的经历都跟他类似了，不过他比我强了非常非常多，在同一个比赛上他拿到了全国一等奖！努力追赶一个人的脚步会让你加速奔跑。</li></ul><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG195_20211127131107.jpeg"></p><ul><li>有ACM竞赛中拿到金牌的CBD（我们叫他C博导），他是一名IO选手，也是ACM金牌选手了，发的一些动态中最让我惊讶的是：大二居然就在搞神经网络，这太强了吧！！！。他还是计算机联合会的会长，还连续三年拿到国家奖学金，博导或许就是这么来的，也参考他的经历，努力鞭策自己成长。</li></ul><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG199_20211127131128.jpeg"></p><ul><li>有“精通”Liunx内核的H哥（我们叫他hui哥），他是我们新生的大助，那个时候主要在研究嵌入式相关的底层原理，看他的经历，给我的感觉就是稳啊， 成为大助本身需要很强的能力，需要给我们这些新生传递良好的价值观等等。</li></ul><p>还有一些参考的经历，就不一一列举了。</p><p>了解了他们的大学经历之后，我好像突然明白了，大学后续能做的一些事情，以及三、四年后的样子。</p><p><strong>这个时候，抬头看路显得多么的重要啊，它能为你带来很多很多启发。</strong></p><p>确实，后面大学几年的时间，都在自己设想的轨道上运行。</p><p>现在工作了，我又开始想要看看以后的样子。于是我又去做一些思考，也很幸运，遇到了我的导师，来字节之前就是他的小迷弟，他也是我的二面面试官，参考了他7年的职场经验，也在给自己设定一些节点和目标。</p><p>导师在毕业前两年一直在坚持写技术博客，他在Stack Overflow上排名前20，写了非常多的技术文章，影响力很大。</p><p>于是，我想我也开始写吧。</p><p>在刚刚毕业之际，也如他的那个时候，时间又刚刚好，或许又能会发生点什么呢？</p><p>最后送大家一句我特别喜欢的话：</p><blockquote><p>不要用战术上的勤奋掩盖战略上的懒惰</p></blockquote><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文彻底理解用户态和内核态</title>
      <link href="/2021/11/20/os-user-and-kernel-model/"/>
      <url>/2021/11/20/os-user-and-kernel-model/</url>
      
        <content type="html"><![CDATA[<p>之前被面试官问到过一个问题：用户态和内核态有什么区别，最近正好在写操作系统专题的文章，拿出来和大家聊聊这个话题，当然理解好这个问题，肯定会有助于你理解操作系统。</p><p>正在阅读的你，有没有想过，操作系统里面讲到的进程、线程，如果分用户态和内核态的话，到底是怎么样存在于操作系统的，又是怎么样调度的呢，用户态线程和内核态线程有什么区别呢？一系列问题，铺天盖地来了，那么今天一起来彻底搞定它。</p><p>首先来看看用户态和内核态是什么？</p><h1 id="用户态、内核态是什么"><a href="#用户态、内核态是什么" class="headerlink" title="用户态、内核态是什么"></a>用户态、内核态是什么</h1><blockquote><p>用户态（user mode）在计算机结构指两项类似的概念。在CPU的设计中，用户态指非特权状态。在此状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他    <a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>    的存储空间，以防止给    <a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>    带来安全隐患。在    <a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>    的设计中，用户态也类似，指非特权的执行状态。    <a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8">内核</a>    禁止此状态下的代码进行潜在危险的操作，比如写入系统配置文件、杀掉其他用户的    <a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B">进程</a>    、重启系统等。<br>引用了一段科学百科的定义，通俗来讲，用户态就是作为用户的我们能够操作的资源的一种形态。那么内核态就是系统内核所能操作的资源的一种形态。</p></blockquote><p>这里提到了两种资源，内核态资源和用户态资源，有两种资源，那么肯定有两种访问权限，需要对着两种资源进行权限控制，其实就是我们CPU工作模式里将到的特权级，CPU特权级分为四级，R0~R3，那么下面来看看CPU指令集的权限控制。</p><h1 id="CPU指令集权限控制"><a href="#CPU指令集权限控制" class="headerlink" title="CPU指令集权限控制"></a>CPU指令集权限控制</h1><p>CPU指令其实也是<strong>分权限</strong>的。低权限的指令和高权限的指令所能访问的资源不一样，这是因为CPU是直接操作硬件的，如果因为操作不当不规范，那么会影响整个计算机系统，关于硬件的操作非常复杂，操作不当出现问题的概率也非常大必须得谨慎使用，然后如果把这个任务留个计算机使用或者开发人员，这无疑是灾难性的。</p><p>所以操作系统充当了这个中间者过程，它屏蔽了底层硬件的复制，抽象出一个个系统调用接口供给开发人员使用。由于本身CPU指令集也分权限，主要分为Ring0~Ring3 这四个级别，高级别权限可访问低级别权限资源，其中我们之前提到的用户态拥有最低权限Ring3，而内核具有最高权限Ring0,可以访问整个计算机资源。</p><p>这么就是CPU指令分权限，下面来看看内核态和用户态的区别。</p><h1 id="用户态和内核态区别"><a href="#用户态和内核态区别" class="headerlink" title="用户态和内核态区别"></a>用户态和内核态区别</h1><p>上面讲了那么多文字，不符合我的风格，直接来图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127124631.png"></p><p>这么一看图，非常情绪，内核态所对应的内核空间就是一个，而用户态所对应的用户空间就随着进程而有多个了。果然是一图胜千言。</p><p>解读一下上图：上图是以32位Liunx操作系统为例的。可以看到内核态在位置是在3<del>4G，而用户的位置是在0</del>3G的，也就是说用户态只能操作0~3G的低位虚拟空间地址，而用户态0-4G的空间地址都可以操作，而且3-4G必须要在内核态中操作，而且可以看到3-4G的位置是各个进程共享的。</p><p>也就是说每个进程拥有自己独立的4G虚拟空间，而最高位1G是一样的，剩下的3G才是自己进程使用。</p><h1 id="用户态与内核态切换"><a href="#用户态与内核态切换" class="headerlink" title="用户态与内核态切换"></a>用户态与内核态切换</h1><p>上面提到了有些资源只有内核态能够访问，所以这些都必须由内核态去执行，那么从用户态切换到内核态就需要有消耗，那么这些开销在哪里呢？主要如下：</p><ul><li><p>保存现场（寄存器上下文等）</p></li><li><p>复制参数&amp;权限检查，将这些参数从用户函数栈切到内核函数栈，进入内核态</p></li><li><p>执行内核代码</p></li><li><p>复制结果到用户态，切回用户态</p></li><li><p>恢复现场<br>实际的切换操作比这个复杂很多，下面来看看常见会发生模态切换的情形：</p></li><li><p>系统调用，系统调用时内核抽象出的给用户态调用的接口，这里无疑会从进行模态切换。</p></li><li><p>异常，当CPU在执行用户态程序时，发生了一些无法预知的异常，这个时候保证程序的正常运行，内核态会接管过来，比如内存管理todo那一篇文章提到的Page fault。</p></li><li><p>中断，中断是值CPU暂停当前执行的指令，切换到与之对应信号的程序去处理程序，比如I/O中断等等。</p></li></ul><h1 id="用户、内核线程模型"><a href="#用户、内核线程模型" class="headerlink" title="用户、内核线程模型"></a>用户、内核线程模型</h1><p>用户态对应使用用户线程，内核态对应使用内核线程。</p><p>当用户线程需要发送一个网络请求的时候，我们知道用户线程是没有权限对网卡等IO设备Ring0级别进行访问的，这个时候怎么办呢？那就得求助与我们的内核线程了，也就是下面要讲到的用户、内核线程模型问题。</p><p>在进入主题之前，我们先来看一下：task_struct 这个数据结构，你可以简单理解为所有的线程、进程都有与之对应的一个这样的数据结构，在进程中，它叫做PCB –&gt; PROCESS control block，进程控制块，而对于线程来讲，它叫做TCB –&gt; thread control block 也就是线程控制块。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127124651.png"></p><p>如图，用户进程的PCB存在于内核空间中，TCB也位于内核空间中，这样内核就可以对TCB进行调度，因为线程是执行任务的最小单位嘛，所以讲到的CPU调度问题，就是针对TCB。</p><p>由于用户线程无法访问Ring0的资源，所以就得有与之对应的内核线程进行接管，也就是上面提到的用户态和内核态的切换，内核线程接管之后会进行一系列处理，然后把结果复制给用户线程，那么这样一次Ring0资源的访问就完成了。</p><p>下面来看看三种对应的模型。</p><h3 id="1：1模型"><a href="#1：1模型" class="headerlink" title="1：1模型"></a>1：1模型</h3><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127124658.png"></p><p>如上图，1对1模型是最简单的一种模型，简单来说就是一个用户线程对应一个内核线程，这里是指用户线程对应内核线程，反过来不一定。这样用户线程就具有了内核线程的权限，可以访问更高级别的资源了，这类模型可以让多线程程序在多处理器的系统上有非常好的表现，但它由有两点缺点：</p><ul><li>很多操作系统限制了内存线程的数量，因此不是每个用户线程都能很好的对应上内核线程，这就受到了限制。</li><li>操作系统内核线程调度的时候，上下文切换开销大， 这也就会导致用户线程执行效率低。<h3 id="n：1模型"><a href="#n：1模型" class="headerlink" title="n：1模型"></a>n：1模型</h3></li></ul><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127124706.png"></p><p>如上图，线程的切换开始由用户线程来进程，这样减小了内核线程切换的代价，所以这种模型线程切换更快速，但是也有最大的问题：如果一个用户线程阻塞了，那么与之对应的内核线程不与其他用户线程对应，也就是所有线程都无法工作，这个时候就出现阻塞情况。</p><h3 id="n：n模型"><a href="#n：n模型" class="headerlink" title="n：n模型"></a>n：n模型</h3><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127124712.png"></p><p>如上图，这类模型拥有了前面两种模型的优化，一个用户线程阻塞不影响整体，在多核CPU系统上，它提升的性能不能1对1模型高。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用户态中运行着程序执行的基本单位——进程，用户进程在内核中有专门的PCB来管理，而一个进程有多个线程，每个线程在内核中有TCB来管理，他们是两个表进行管理的。用户线程需要访问内核资源权限的时候就切换到与之对应的内核线程执行。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解！三个问题带你彻底理解内存管理</title>
      <link href="/2021/11/16/os-mm/"/>
      <url>/2021/11/16/os-mm/</url>
      
        <content type="html"><![CDATA[<p>面试的时候是不是经常面试官被问到一个问题：有了解过虚拟内存吗？那你详细讲讲你了解的虚拟内存吧。我在去年秋招的时候也经常被问题这个问题，那么今天好好来和你一起研究探究这个操作系统的内存管理。</p><p>下面就通过一个例子，带你进入操作系统内存管理的世界。</p><blockquote><p>首先，假设我们的内存空间有 64MB，现在我需要运行三个程序，其中程序 A 运行时需要占用的大小为 32MB，程序 B 运行时占用的大小为 30MB，程序 C 运行时占用大小 4MB，那么很显然如果三个程序一起运行，肯定会有地址冲突，因为装不下啊，这只是其中一个问题，还有另外一种问题，程序 A 和 B 一起运行时，如何确保 AB 的程序地址不冲突呢，你可能会想到说，在代码里面写好，让他们不冲突即可，但是那我假如要运行程序 C 呢？ 是让 B 退出运行还是让 A 退出运行，那程序 C 的地址如何确定，那是不是就得在代码中变化了，虽然 AB两个程序没有出现相互访问的情况，还可以控制，但是程序一旦多起来，就要为了内存地址”打架了”。这个例子中所有的空间地址都硬编码在了程序里，所以每次要改地址的时候就得改程序，这种最原始的地址使用就出现了很多问题。</p></blockquote><p>通过上面的例子想必你已经发现问题了。</p><p>也就是如题，三个问题带你彻底解决内存管理，那么是哪三个问题呢？如下图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121308.png"></p><p>针对以上三个问题，我们逐一解决，首先是地址空间不隔离问题。</p><h1 id="地址空间不隔离"><a href="#地址空间不隔离" class="headerlink" title="地址空间不隔离"></a>地址空间不隔离</h1><p>在计算机学科里有一句名言：</p><blockquote><p>计算机科学领域的任何一个问题都可以增加一个中间层来解决。</p></blockquote><p>对于这类隔离问题也是这样，不如我们在真实的内存地址上增加一层试试看，我们就叫它虚拟地址吧，既然是虚拟地址，那就可以随意让我们来定值了，只要在运行的时候找到一个与之对应的物理地址去运行就可以了。</p><p>通过添加虚拟地址，两个运行的程序就无法知道对方的地址（这里暂且不讲进程间通信）。</p><p>所以这个问题就这样得到解决，那么新增加了这个虚拟地址到底该如何与真实地址对应上呢？</p><p>所以得提供一个 y = f(x) 这样一个转换 关系，这个转换关系在计算机系统设计的时候存在于真实物理地址中，而操作这个转换关系的物价叫做<strong>内存管理单元（MMU，Memory Management Unit）</strong>，具体详细情况，请看图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121336.png"></p><p>MMU 常见情况存在于 CPU 芯片中，也有一些独立于 CPU 的，通过虚拟内存解决了第一个问题，下面来看看第二问题。</p><h1 id="地址空间不确定"><a href="#地址空间不确定" class="headerlink" title="地址空间不确定"></a>地址空间不确定</h1><p>地址空间不确定的原因就是不知道程序到底应该运行在哪里，有了上面的虚拟内存，其实地址空间也可以确定下来了，不过比较笨，两个程序的虚拟内存是一样的，对应到物理内存的话不一样也可以，那就得全靠MMU了，为了改变这种比较笨的局面以及随着 CPU 的发展，就出现了一种内存管理技术——内存分段。</p><h3 id="16-位-CPU-的内存分段"><a href="#16-位-CPU-的内存分段" class="headerlink" title="16 位 CPU 的内存分段"></a>16 位 CPU 的内存分段</h3><p>内存分段模型最早出现在 8086CPU 中，<strong>8086 的段寄存器只有 16 位，而地址总线有 20 位</strong>，为了解决这一不匹配，就引出了代码段寄存器和 IP 指令寄存器，段寄存器左移四位+IP 寄存器的值就是内存地址了，而程序又会分为数据段、代码段、堆等一个个段，每个段都有响应的寄存器对应，比如需要代码段的时候 CS 寄存器就开始工作了、需要数据段的时候 DS 寄存器就开始工作了等等。这也就是最早内存分段模型，计算例子，如下图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121347.png"></p><p>在<a href="https://mp.weixin.qq.com/s/wtNuOyUDM0uORKpKYA-8XA">深入浅出 CPU 的两种工作模式</a>一文中有着详细的介绍 8086 的历史起源、寻址原理等，你可以跳转到那篇文章仔细阅读。</p><p>上面提到了<strong>程序有会分为很多段，比如数据段、代码段等等</strong>，那么这些段是如何来的呢？</p><p>这个时候就得引出我们的<strong>编译技术</strong>了，编译技术其实在没有内存分段的时候已经有了，比如写了那么多汇编指令，得转换成二进制格式的代码，就得用到汇编器了，它的作用你肯定也猜到了，就是将汇编代码转成二进制格式目标文件代码，也就是我们所说的<strong>机器语言</strong>，汇编器也是最早的编译技术，当然汇编完成之后，还要有链接的过程，链接器的作用就是开始对程序进行分段合并处理，编译汇编的时候会对程序分段也会做一些处理，不过最主要的是在链接过程具体过程如下图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121435.png"></p><p>没有内存分段的时候汇编器也比较粗糙，就是无脑对应一条条指令翻译汇编代码就好了，因为这个时候的空间地址完全由汇编代码决定，那么内存分段之后，将一个可执行的二进制文件，分成了很多段，这个时候得益于我们编译技术，它帮我们处理了分段模型，最后的二进制文件就是一段一段的。主题与篇幅原因，这里不做展开，牢记二进制是一段一段的就可以了，后续也会专门分享这个二进制文件到底是个什么样子的。</p><p>程序既然是一段一段的了，那么 CPU 读取程序指令的时候，不也得有分工，所谓<strong>术业有专攻</strong></p><p>那么就是我们开始提到的 CS 段读取指令，DS 段读取数据了，还有很多 CPU 的寄存器去做不同的事情，一些常用的寄存器用处，如下图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121445.png"></p><p>我相信你读到这里，肯定豁然开朗，原来内存分段得这么多技术一起配合啊，没错就是需要这么多计算机体系知识一起配合完成，操作系统也是类似，它不仅仅在操作系统层面有难度，编译技术也得更上，所以你也明白自研操作系统的难度了吧，16 位处理还是比较简单的，到 64 位处理起来更加复杂，而计算机就是由国外 16 位发展而来的，甚至 16 位之前还有很多研究，而到国内应用起来就是 32 位、64 位的，没有基础理论的研究，上来就肝 32、64 位的话太难，做<strong>一款成熟</strong>的操作系统真的太难，好在有华为的鸿蒙，你会说不喜欢用、不好用，但看到这里相信你也会慢慢原谅当前的鸿蒙（我专门体验了很久鸿蒙，感觉还行~），给它时间吧。</p><p>扯了一段爱国情怀，继续回到本文主题，16 位的内存分段，已经讲解完了，接下来我们看看 32 位的内存分段。</p><p>在进入 32 位内存分段模型前，先简单来看一个问题：</p><blockquote><p>上面我们知道，16 位的寻址方式最大能寻址 cs=0xffff,ip=0xffff 也就是 0x10ffef 这么大了。这个地址算下来也就 1M 多，1M 多是什么概念？你现在打开相机随意拍一张照片可能都比这个大了，实在是太小了，稍有多的东西就放不下了。那怎么办？当然是扩展 16 位到 32 位了。到了 32 位之后，为了兼容原来的 ax,bx 等寄存器，就在高位扩展了 16 位，而低 16 位依然不变，由高位 8AH 和低 8 位 AL 组成，具体为什么要这么做，而不是直接换成两个 16 位寄存器，，那得问 Intel 的工程师们了。<br>扩展成 32 位之后，系统能运行更多的程序，而表示一个程序的内存地址的代价也会增加，表示一个程序内存地址的数据已经不在适合放在 32 位的寄存器中了，因为太大了，放不下，具体是如何放不下的，请接着往下阅读，既然放不下就得寻求新的方式了，这就是 32 位 CPU 内存分段的知识了。</p></blockquote><p>下面进入 32 位 CPU 内存分段一起解决上面提到的问题。</p><h3 id="32-位-CPU-的内存分段"><a href="#32-位-CPU-的内存分段" class="headerlink" title="32 位 CPU 的内存分段"></a>32 位 CPU 的内存分段</h3><p>话不多说，上图，寻址原理一起看图说话。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121502.png"></p><p>上面提到的寄存器放不下这么多大量的信息，所以就得寻求改变，最终就是如上图一样进行了改变，别怕，我带你一起解析这幅图。</p><p>这时候虚拟地址由两部分组成，段选择子和偏移量，在<a href="https://mp.weixin.qq.com/s/wtNuOyUDM0uORKpKYA-8XA">CPU 工作模式</a>一文有详细提及。</p><ul><li>段选择子里面有三个信息：段描述符的索引、TL 位以及请求特权级位。</li><li>偏移量就是从段描述符表中取到地址后需要去寻找真正的物理地址的一个索引定位。</li></ul><p>上图的主要工作流程为： 首先虚拟地址中的段选择子会根据自身信息与 GDTR 寄存器配合，在段描述符表中找到需要的段描述符位置，从段描述符的信息中拿到段的起始地址，然后根据虚拟地址中的偏移量进行精确定位到物理地址，这就是分段机制下，从虚拟地址找对于的物理地址方法。</p><p>然而是分段类型，具体的分段机制大概是分成：数据段、代码段、堆段、栈段、BSS 段等等，如下图，在映射到物理地址的时候，就是一段一段映射的，这个段就比较大块。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121516.png"></p><p>讲解完 32 位 CPU 内存分段模型，你肯定发现了，在程序切换的时候会出现大块内存交换的情况，所谓内存交换就是如果要运行 A 程序要 100MB，但是现在发现连续内存不够了，但是空闲的不联系的内存之和大于 100MB，这个时候操作系统会把这些空闲的内存通过交换的方式得到一片连续的空间，这样 A 就能运行了，具体的话，请看图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121600.png"></p><p>如上图，<strong>将中间 40MB 空闲内存和 C 程序运行的 70MB 进行交换</strong>，得到 90MB 空闲内存，这时候 A 就行加载进去运行了。20MB、40MB、50MB 这没有运行程序的空闲地址，但又不能运行程序，这就是内存碎片了。</p><p>大块内存交换不用想肯定效率低，切换块太大的话还会容易产生内存碎片，下面我们就来讲解如何解决这些问题的。</p><h1 id="内存使用效率过低"><a href="#内存使用效率过低" class="headerlink" title="内存使用效率过低"></a>内存使用效率过低</h1><p>内存使用效率过低表现为两个方面：</p><ul><li>内存使用率太低、内存碎片的出现；</li><li>内存交换速度太慢，大块交换容易卡顿。</li></ul><p>所以就出现了内存分页技术，所谓分页技术就是把虚拟内存和物理内存分成固定的大小，每个大小相同的东西叫做<strong>页</strong>，也就是每一页都是相同大小的，而这个页的大小一般由硬件规格决定，一般可支持多种大小，这个时候操作系统来选择其中一种大小，这就是分页。下面具体来看看分页时的一些寻址原理等知识。</p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>这里我们选取 4KB 大小为一页进行讲解 ，这个大小是无所谓的，重点在于原理。</p><h4 id="一个例子探究分页"><a href="#一个例子探究分页" class="headerlink" title="一个例子探究分页"></a>一个例子探究分页</h4><p>现在，计算机有 32KB 内存大小，假设每页 4KB，也就是从 VP1 到 VP8，我们有 2 个程序 A 和 B，A 运行时被映射到 VP1、VP3、VP5，B 程序运行时需要 VP1、VP2、VP3。开始运行的时候，B 程序的 VP2 没有被映射到物理内存。看图</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121609.png"></p><p>当程序 B 运行时，需要读取 VP2 时，发现物理内存中，并没有与之对应的内容，这个时候就会触发页错误（Page Fault），就需要进行一次换入（Page In）操作，你肯定也会想到换出（Page Out）,这是从内存中保存到磁盘里的操作，了解这一原理，你可能会想到，一次换入操作肯定会有消耗，那打开一个应用或者启动一个程序时，是不是可以减少这类操作从而优化启动耗时呢。你看掌握原理，你的思维有多发散，原理的重要性不言而喻。</p><p>上面就是基本的分页两个操作，你会发现，分页完之后，都是一页一页的换入换出操作，非常简便，没有一大段那么沉重了，自然就解决了交换速度太慢的问题，其实不仅于此，是不是还解决了内存碎片的问题呢，把物理内存分成一页一页，用到的时候就一个个换入，这样下来就没有碎片了。</p><h4 id="寻址原理"><a href="#寻址原理" class="headerlink" title="寻址原理"></a>寻址原理</h4><p>分页时解决了这些问题，那么它是如何寻址的呢？请看图</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127121619.png"></p><p>分页之后，虚拟地址包含<strong>页号</strong>和<strong>偏移量</strong>，页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</p><p>内存分页之后每个页都是很小块，在进行内存交换的时候，使用效率过低的问就解决了，也不会出现大块交换卡顿，大块内存碎片的情况。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从没有内存管理的三个问题，带你进入内存管理的世界，通过一个个例子，解决了内存管理的空间地址不隔离、不确定、使用效率过低的三个问题，期待更多的图解知识，请长期关注作者。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机人应该如何高质量地度过大学四年</title>
      <link href="/2021/11/15/ex-da4/"/>
      <url>/2021/11/15/ex-da4/</url>
      
        <content type="html"><![CDATA[<p>今天来和大家聊聊计算机人应该如何高质量地走完大学四年。下面将我在大学四年走过的那些经验分享与你，让你站在未来看现在的自己。 </p><p>如果笔者以现在的心态重回大一，我一定按照下面的路线学习。</p><p>这个问题也可以看成：如何规划自己的大学四年？ </p><p>那么既然是规划，必然得从目标出发，有了目标才能明确方向。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前言主要聊聊明确好目标， 那么如何明确目标呢？</p><p>其实绝大部分刚进入大学的同学都是非常迷茫的，笔者也是这样，刚进入大一的时候，虽然有比较强烈的学习欲望，但是却不知道为什么要学习，努力学习是为了达到一个什么样的水平？别的同学都是打游戏，我是不是也应该跟他们一样整天玩乐？大学是真的就不用学习了吗？这些问题都是笔者当时所遇到的，或许你也会遇到。</p><p>当时非常有幸参与了某位学长的经验分享，一下子就茅塞顿开有目标了。</p><p>在这里，我想以一位过来人的身份将自己的经历完全分享给你，希望对你有所启发。我们这里讨论的明确目标不讨论读研还是工作，到底是读研还是工作，其实这是一个值得认真做决策的事情，这里我们只讨论一个目标：提高自己的计算机水平并且热爱上它。 </p><p>为什么说只讨论这个目标呢？</p><p>因为你已经是一个计算机人了，不管是出于什么原因选择计算机专业的，你已经加入其中来了，选择面对而不要逃避。所以请认真提高计算机水平且热爱上它，这不管对于你大四考研还是工作面试，都是必须的。 </p><p>那么，又有一个疑问来了，提高自己的计算机水平到一个什么样的水平呢？</p><ul><li><p><strong>第一：能够掌握计算机世界里常见的数据结构与算法且能随时手写实现。（算法）</strong> </p></li><li><p><strong>第二：能够非常详细且清楚形象地解释一行行代码是如何被计算机执行起来的。（编译、链接、运行）</strong> </p></li><li><p>**第三：能够非常清楚多台计算机之间是如何通信的（网络） **</p></li><li><p><strong>第四：能够非常清楚我们这些信息数据是如何存储的 （数据库，准确来说它也属于应用范畴）</strong></p></li></ul><p>能够很好的掌握以上四个问题，基本上计算机的基础知识已经基本理解了。</p><p>​别看只有四个问题，其实这四个问题相互牵扯、联系，涉及范围很广。</p><p>好了，目标已然明确，那就开始做行动的巨人吧。</p><p>进入主题之前需要明确一点： <strong>一定要学会自学编程！一定要学会自学编程！！一定要学会自学编程！！</strong></p><h1 id="课程体系"><a href="#课程体系" class="headerlink" title="课程体系"></a>课程体系</h1><p>下面是网易云课堂的计算机学生培养体系，语言主要集中在C/C++/java/python 然后是一些基础知识。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG178_20211127131755.jpeg"></p><p>这张图汇聚了很多大佬的经验，不敢随意点评。 </p><p>这里是随意说一点：**大学期间学习的编程语言在于精，而不在于多。 **</p><p>除了上图编程语言过多之外，可以看出在计算机基础理论方面比较重视，所以我们重点以C/C++来谈谈计算机基础理论知识。</p><p>下面的学什么，主要围绕计算机体系展开，没有包括大学里必修的一些课程，必修课程也是必须要学习的，比如离散数学，数电模电等，这也会为你在计算机路上提供很大的帮助。</p><p><strong>把这些知识融会贯通，毕业你就能进大厂，加以刷题练习，你就能在考研专业课中得高分。</strong></p><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2><h3 id="主要学什么？"><a href="#主要学什么？" class="headerlink" title="主要学什么？"></a>主要学什么？</h3><p>大一这一年，非常简单，你就应该学习数据结构和算法以及C/c++语言。然后一直不断地做算法题，不管你是不是有想法、有机会参加ACM校队（如果能够参加，强烈建议参加），大一这一年持续刷题和学习数据结构就行了，有机会有条件就去参加蓝桥杯（不要说它很水，先拿到省一，然后去北京打国赛再说），努力拿到省一的水平，基本上基础算法也就掌握了，不要考虑去做前端那么炫酷的页面等等应用开发，当然如果你非常有兴趣，可以花少部分精力去尝试。</p><p>为什么需要把数据结构与算法的基础打牢呢？ </p><p>第一：不管是你大四面试还是考研，做算法题和写数据结构题都是必须的。 </p><p>第二：数据结构与算法是整个计算机基础理论的基石，基础不牢，地动山摇。 </p><p>第三：数据结构与算法很大程度上不牵扯到其他计算机知识，比较容易上手和深入。 </p><p>第四：你能够积累代码量，这为你以后开发应用做了最好的铺垫。</p><h3 id="如何学？"><a href="#如何学？" class="headerlink" title="如何学？"></a>如何学？</h3><p>第一步：如果没有C语言基础，首先学习c语言基本的语法、语句，写一些简单的程序，打印三角形之类的，多写一些简单的程序，这个是主要熟悉C语言的特性以及编程入门。 </p><p>第二步：选择杭电oj开始做题，网上有很多新手做题的顺序，具体如何操作可以自行百度（学会搜索也是计算机人所必须具备的能力）。 </p><p>第三步：杭电oj基础题大概做到100道差不多了，这期间肯定会遇到一些简单的算法问题，比如冒泡排序等等，开始学习算法的基本知识，比如时空复杂度等等。 </p><p>第四步：算法的基本知识学完了，你学会衡量一个算法的快慢了，那么接下来你可以开始进攻数据结构了，把基础数据结构都自己实现一遍。 </p><p>第五步：基础数据结构与算法都学习差不多了，开始进入算法攻坚，这里主要是竞赛中比较基础的算法，比如：DP、DFS、BFS等等了。 </p><p>第六步：基础算法学习完了之后，如果对ACM比较有兴趣，强烈建议加入去参加竞赛，具体ACM的算法网上有很多总结，也包括知识点总结等等，将ACM的基础竞赛算法都学习一篇。 </p><p>第七步：利用已学的数据结构和算法，做一个整体的C语言系统，可以把所学习的算法和数据结构整合到一起，形成一个小系统总结。最后学习github使用，将小系统代码提交到github上。 </p><p>第八步：如果还有余力，建议开始啃算法导论这本黑书。</p><p><strong>以上步骤，写代码过程中，一定不要自欺欺人抄袭模板，所有代码都要自己编写，并且是通过理解之后的编写，以便于你比赛或者面试信手拈来。</strong></p><p>到这里，你已经可以很好的回答开篇中提到的第一个问题了。</p><p>​下面是推荐的相关书籍： </p><p>C语言入门： 谭浩强《C语言入门到精通》 </p><p>数据结构: 《大话数据结构》 </p><p>算法: 《挑战程序设计竞赛》 《算法竞赛》《算法导论》</p><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h2><h3 id="主要学什么？-1"><a href="#主要学什么？-1" class="headerlink" title="主要学什么？"></a>主要学什么？</h3><p>大二这一年在大一的基础上把C++深入进攻，建立以C++为核心的知识体系。 </p><p>为什么是C++，而不是Java、Python? </p><p>首先明确不是说Java、Python不行，是因为C++更接近计算机硬件，它能够让你更加深刻理解并切身体会计算机体系的精髓，仅因为C的精髓——指针，粗略理解指针就是内存地址，那么如何理解内存，下面的知识就来了。</p><p><strong>预备知识：汇编语言（8086汇编）&amp;C/C++相关语言特性</strong> </p><p>汇编语言作为了预备的知识，因为做了那么多道题，写了那么多C代码，学习汇编这种低级语言，会容易上手了，这也会后续学习打下铺垫，这里推荐是8086汇编，因为8086汇编是CPU在实模式下工作，是最简单的一种了，学习嘛，从简单到复杂。 汇编语言让你体验CPU指令式的编程。</p><p><strong>第一门课：计算机组成原理</strong> </p><p>这是掌握计算机组成的重要课程，你必须得掌握它才能理解计算机的运行原理，组成原理等，前期开始学习，你会比较痛苦，因为过于抽象，这也是公认非常难的一门课，笔者在整个大学四年，这门课的分数最低，拿下它，看到另一片风景。</p><p><strong>第二门课：操作系统</strong></p><p>操作系统不用说了，这也是必须要开始掌握的，掌握好操作系统，你才能知道你在大一那一年写了那么多exe文件，是如何运行的，操作系统又是如何调度硬件设备的，这也是一门开始学习非常难的课，不过爬过了计算机组成原理的坑，这里会好不少。 </p><p><strong>第三门课：编译原理</strong> </p><p>为什么第三门课是编译原理，因为只有掌握了这个，你才能理解你写的#include&lt;stdio.h&gt; 这类语句被转化成了什么，最后又是什么。这门课，笔者老师说是大学里最难的一门，因为设计到太多的数学推到等等，不过这里你掌握大概的理论就差不多了，计算机领域数学上面的知识，不是做研究的，很少有机会用到。 到这里你可以回答开篇提到的第二个问题了，你就能理解「一个程序是如何跑起来的了」</p><p><strong>第四门课：计算机网络</strong> </p><p>计算机网络是连接多台计算机从而衍生出来的一个计算机体系分支，你在学习的时候抓住一条主线学习 「数据包是如何发送出去的」，你把这个问题弄清楚，计算机网络体系的知识也就掌握差不多了。也能回答第三个问题，计算机是如何通信的了。</p><p><strong>第五门课：数据库原理</strong> </p><p>一般学校也会在大二开设这门课，跟着老师学习就可以了，因为你目前没有涉及到应用开发，应用起来也比较无从下手，所以跟着学校老师的实验一个个做完，然后深入理解其中的原理，比如索引、事物等概念原理。 这里你就能回答第四个问题了。</p><h3 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h3><p>首先，这类理论课往往很枯燥，很难集中精力理解学习，又或者说学习了又忘，无法深刻理解其本质，前面提到了预备知识汇编语言，那么就从汇编语言和C/C++下手吧，C/C++已经写了很多代码了，比较熟悉了，关键是汇编语言，才接触，又是各类指令符号，太难了！！！其实不难，汇编语言其实简单，他就是靠指令堆积起来的程序，没啥好可怕的，学习好它相关的寄存器知识就可以开始学指令了，学习过程中，最主要的是做实验！！！ 一定要动手！！！ 动手起来，最好是跟着视频教程一起学习。 </p><p>学习了汇编，你会第一次接触到硬件编程，你会操作CPU的寄存器、你会接触总线。这里就为计算机组成原理学习打下铺垫了。</p><p>到了计算机组成原理，建议跟着视频来一起学习，网上有很多讲的比较好的视频，这里又考验大家的信息搜集以及甄别能力了。 其实这块，你主要理解计算机的各大部件是干嘛的，以及是如何工作的，能够理解明白就算是入门了。</p><p>到了操作系统这块，跟之前一样跟着视频一起学习。这里你就会明白一个程序到底是如何运行的。主要掌握，系统初始化、进程管理、内存管理、文件系统等模块的知识。 </p><p>然后是编译原理，编译原理这门课从理论来讲其实还是比较好入门的，笔者当初就是在图书馆借了本清华大学的书在看，然后就入门了。到编译原理这门课，你应该开始养成看书的习惯了，看视频的不好的地方就是非常容易忘记。学习完编译原理，你掌握了源码如何构建成产物了，这样你的知识就连贯起来了，你能够结合计算机组成体系以及操作系统还有编译原理三门课讲清楚第二个问题了。</p><p>然后是计算机网络、数据库，上面都提到了。</p><p>最后，为了大学学习有亮点，你可以写一个小型的C编译器或者json解释器等等，加深对编译原理的理解。</p><p><strong>这些小型的项目都可以作为你建立里面的加分项，这非常能力体现你的学习以及动手能力，企业&amp;研究生不就是需要这种人吗？</strong></p><p>​下面是推荐的书籍： </p><p>汇编语言：这块笔者是跟着教材学习的，没有买书就不推荐了！ </p><p>《深入理解计算机系统》这本书涵盖了整个计算机体系知识，认真阅读这本书，就可以连贯上面前三门课的知识 。</p><p>其他一些书籍也可以结合起来看： 《程序员自我修养》《现代操作系统》《自制脚本语言》《深入理解C指针》《C++ Primer》《图解 HTTP》《计算机网络：自顶向下方法》</p><p>以上提到的四个问题都能回答了，恭喜你，计算机的基础体系知识以及差不多掌握了，接下来就是要深入挖掘了，给自己的简历添加亮点。用实际项目证明自己的能力。</p><h2 id="大三上"><a href="#大三上" class="headerlink" title="大三上"></a>大三上</h2><h3 id="主要学什么"><a href="#主要学什么" class="headerlink" title="主要学什么"></a>主要学什么</h3><p>大三上你就主要研究liunx系统吧，前面你已经有C/C++做的一些小项目经验了，那么这个时候利用熟悉的C/C++，你可以开始研究Liunx系统内核了。 </p><p>为什么这里推荐深入Liunx? </p><p>原因有很多：Liunx源码开放，直接看源码理解CPU任务调度、进程线程如何表示等等；Liunx又是工作或者读研必定会用到的，提前准备何尝不可呢；面试的时候与面试官对吹Liunx内核，你还能面试不过？</p><p>有很多原因，这里就不一一例举了。</p><h3 id="如何学习？-1"><a href="#如何学习？-1" class="headerlink" title="如何学习？"></a>如何学习？</h3><p>首先，探究Liunx底层原理最好的办法就是把它跑起来，参考Liunx以及其他操作系统架构，做一个微内核，一边理解，一边撸内核，比如系统初始化的时候，Liunx到底初始化了一些什么东西？ 你自己的微内核也需要初始化，这样你就非常清楚Liunx系统初始化的时候是在干什么了。初始化完了之后，你需要对CPU进行操作，就需要进程管理，你手写的进程管理代码，肯定比不上Liunx的进程管理代码，但是重点就在于，你自己实现了一遍，这个印象是非常深刻的。</p><p> 等你实现玩一个微内核之后，你就会感叹原来操作系统，自己也能实现。不过这个过程异常艰难。这就是简历中的亮点。艰难是因为操作系统本身非常抽象，然后还要自己实现一个，国内的操作系统都做得不出色。</p><p>总结下来就是，一边学习Liunx源码，一边自己实现微内核。 </p><p>推荐书籍： 《深入Liunx内核架构》《Liunx内核源码分析》</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>为什么写到大三上就不写了，因为大学给计算机专业同学学习打基础的时间就是这么多了。大三下，你可能会选择春招实习或者考研复习。找到实习之后，基本上你就已经踏入社会开始实习了，当然你会选择不实习而留在学校，享受校园生活，这也无可厚非。大三下开始，你根本很难有时间去学习了。</p><p><strong>最后你也可以发现，大学其实表面上是4年，其实只有两年半，那么也就是这两年半的时间，你要在计算机领域中度过从零到一。</strong></p><p>说到这里，你是不是突然觉得时间紧迫了。不得不承认，计算机的知识非常抽象，如果你不潜心学习，很难度过从零到一，甚至你到毕业了还不能完整的理解上面提到的那些计算机体系内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者在学校做了很多应用类项目，其实在面试的时候根本没有核心竞争力，可以说大学里面做的那些页面、crud项目绝大部分都太水，无法吸引面试官的眼球，所以直接放弃吧，不要被炫酷的页面所迷倒，现在的轮子太多，github随手拿一个。</p><p>那么如何有核心竞争力呢？</p><p>就是上面提到的，<strong>一个计算机人所必须具备的基本素养，你得明白，你写的每一行代码在计算机在中是什么样子，它是如何执行的，它会耗费多少CPU资源等，这很难，也很酷，不是吗？</strong></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>期待正在阅读的你，认认真真走完大学四年，并学有所成。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出CPU的两种工作模式</title>
      <link href="/2021/11/11/os-cpu-work-model/"/>
      <url>/2021/11/11/os-cpu-work-model/</url>
      
        <content type="html"><![CDATA[<p>上期文章 是关于Linux启动的，在启动的时候会切换CPU模式，从实模式到保护模式，有小伙伴咨询到我说想详细了解下这两种模式。</p><p>那么，本期来跟你们唠嗑一下CPU工作模式，一起彻底理解CPU工作模式。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>寄存器就是用来存取数据的，在CPU运算的时候主要靠寄存器来进行数据存取。</li><li>寄存器的位数就代表这CPU能运行的位数，比如32位机器，就是说寄存器的位数有32位，一般32位的话，就是EAX 这种，包含高16位和低16位，，低16位有包含高八位AH和低八位AL。</li></ul><p>进入正题。</p><h1 id="实模式部分"><a href="#实模式部分" class="headerlink" title="实模式部分"></a>实模式部分</h1><p>CPU的工作模式，简单概括就是CPU在工作的时候是如何寻址的，那么在实模式下，我们很容易猜测到是寻找实实在在的内存地址，没错，实模式工作时，是<strong>寻找真实的物理地址</strong>，而且<strong>没有加任何限制</strong>，下面我们先来看看历史起源。</p><h3 id="历史起源"><a href="#历史起源" class="headerlink" title="历史起源"></a>历史起源</h3><p>CPU的实模式工作模式就起源于8086处理器，这也是第一款支持内存分段的处理器，此时的CPU就工作在实模式下，8086这款处理的寄存器位数只有16位，寄存器只有16位的话，那么它最大的表示范围为：2^16 = 64 K，也就是说此时寄存器能够存储的最大的值就是64K - 1，大于这个值就放不下了，但8086处理器的地址总线有20根，也就是20位，20位的寻址空间可达到 2^32B = 1024K = 1M，所以地址总线能传这么大的数，但是寄存器却存不下，</p><p>为了解决这一不匹配带来的问题，必须要采用一种方式给它俩匹配上，而这种方式，就是下面寻址原理提到的方式。</p><h3 id="寻址原理"><a href="#寻址原理" class="headerlink" title="寻址原理"></a>寻址原理</h3><p>在上一期关于<a href="https://mp.weixin.qq.com/s/_hSLAZPSw_zSZQ0W9V-Fiw">Linux启动</a>的文章中，我们知道内存地址的表示是由代码段寄存器CS和指令寄存器IP完成的，前者代表段基地址，后者代表段内偏移地址。他们都是16位的，为了和20位地址总线匹配，会进行如下：<strong>先将cs寄存器的值左移四位，然后再与ip寄存器的值相加</strong>，这么以转换，就得到了一个20位的数据大小了，如下所示：</p><p><strong>真实物理地址 = 段基址 &lt;&lt;&lt;&lt; 4  + 段内偏移地址</strong></p><p>我们现在假设 段基址的值也就是cs寄存器的值 =  0xFFFF , 段内偏移地址也就是 ip寄存器的值为 0x0000， 那么最终的真实物理地址为：</p><p><strong>0xffff &lt;&lt;&lt;&lt; 4 + 0x0000 = 0xffff0 + 0x0000 = 0xffff0</strong></p><p>最终结果就是 0xffff0 了</p><p>通过原理的介绍以及例子的讲解，我们弄清楚了实模式下的CPU寻址原理，也就是（cs:ip）</p><p>其实还有一点没有跟你提到，我们前面所描述的寻址原理，是通过段基地址和段内偏移地址找到的内存地址，这就是在操作系统进行内存管理的第一大跨越，著名的内存分段模型。</p><h3 id="8086CPU的问题"><a href="#8086CPU的问题" class="headerlink" title="8086CPU的问题"></a>8086CPU的问题</h3><p>通过上面的描述，细心的你，肯定发了问题。</p><p>你会发现用到的既然都是真实的物理地址，是不是随意一个能表示的地址都可以访问？</p><p>这就出现了两个程序之间的地址空间没有界限，就可以相互随意干扰，所以就得给内存地址加上保护机制。</p><p>你还会发现代码段寄存器和指令寄存器所能表示的最大寻址地址为0xFFFF:0xFFFF = 0x10FFEF</p><p>这个地址已经比1M要大了，那超过1M怎么办呢，地址总线就那么20根，这个时候8086CPU采取的办法就是高位被抛弃，也就是我们现在说的数据溢出（Overflow）了。</p><p>为了解决这些问题保护模式机制就诞生了。</p><h1 id="保护模式部分"><a href="#保护模式部分" class="headerlink" title="保护模式部分"></a>保护模式部分</h1><p>保护模式出现的原因就是为了解决实模式下出现的问题，保护，顾名思义：就是保护进程地址空间，程序A的地址空间，不能随意被程序B访问。</p><p>保护模式下的概念稍多，我们先来看看几个概念。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="执行权限（CPU特权级）"><a href="#执行权限（CPU特权级）" class="headerlink" title="执行权限（CPU特权级）"></a>执行权限（CPU特权级）</h3><p>既然是需要保护内存地址空间，那么肯定有些指令得有执行的权限控制，CPU就实现了特权级，如图</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG216_20211127102824.png"></p><p>从里往外权限依次降低，可以看到内核态具有最高权限即Ring 0 拥有最高权限，可以访问低特权级的资源，而反过来却不行。</p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>这里32位CPU中的寄存器相比于16位发生了改变，原来16位寄存器可以存放下段基地址和段内偏移地址，而变到32位，还需要存储其他信息，肯定放不下了。放不下，就需要想办法去解决，这个时候就去找内存借用空间，然后把描述一个段的信息封装成特定格式的描述符，存放在内存中，这个描述符就被称为段描述符，它包含两个双字，也就是64位8字节数据，里面包含了段基地址、段长度、权限、类型等等信息，具体就来看图吧！</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127102906.png"></p><p>那么段描述符肯定不止一个，多个段描述符在内存中，就形成了一个表，这个表叫做全局段描述符表（GDT，Global Descriptor Table），这个表的基地址是由GDTR寄存器指向。这个寄存器在保护模式初始化的时候会加载一个值，这个值就指向了GDT，这样要寻址的时候就会先来到这里，而在寄存器中，不在是存放段基址，而是一个指向段描述符表的索引。所以这里就从根本上改变了寻址方式了。</p><h3 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h3><p>上面提到的指向段描述符表的索引就属于段选择子的一部分，具体结构如下图：</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127102920.png"></p><ul><li>索引：表示在段描述附表中的索引位置</li><li>TL：Table Indicator 表示是去GDT表查找还是LDT（局部描述符表）</li><li>RPL：请求特权级，以什么样的特权级访问段信息。</li></ul><p>段选择子又属于属于段寄存器的一部分，它是一个16位的整数（这是16位可见部分）记录了GDT表的段描述符的具体索引位置，以及请求特权级和描述符表类型以及段描述符表索引。</p><h2 id="寻址原理-1"><a href="#寻址原理-1" class="headerlink" title="寻址原理"></a>寻址原理</h2><p>保护模式的寻址原理，就没有实模式那么简单了，首先在保护模式下，cs寄存器的低16位存储的是上面提到的段选择子的信息，在寻址的时候，会根据GDTR寄存器找到基址，然后根据cs寄存器里面的段选择子信息，进行偏移读取，读取完了之后，其实这个时候已经找到了程序执行的地址，接下来就<strong>会根据段描述符进行对段寄存器的填充，主要是填充不可见的那一部分</strong>，段寄存器的大致分布如下。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">struct Segment&#123;  WORD selector;  //16位段选择子          WORD attribute; //16位表示的段属性  DWORD base;     //32位表示的基址始  DWORD limit;    //32位表示&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们前面提到了，段选择子是段寄存器的一部分，如上面代码 selector 就是表示选择子，而下面的三个属性是不可见的。attribute 属性标注了段的属性，是可读还是可写还是可执行的，base属性表示了段从哪里开始，limit和base就可以确定一个段的大小。<br>除了段选择子可见外，后面的三个部分对程序员是不可见的，那么我们如何得知这三部分的存在呢？这里需要做一些相关的实验室，后续见~</p><p>填充完了之后，段寄存器中有内存地址信息了。</p><p>弄清楚了保护模式的寻址原理了，是不是还想知道，实模式下，究竟如何切到到保护模式呢？</p><h1 id="实模式切换到保护模式"><a href="#实模式切换到保护模式" class="headerlink" title="实模式切换到保护模式"></a>实模式切换到保护模式</h1><p>x86的CPU在每次加电或者reset的时候，都是先进入到的是实模式，如果要切换到保护模式得需要程序引导，这个引导，我们上期提到过了，在启动的时候是存在GRUB中的，根据上文，我们回忆一下，切到保护模式的寻址方式发生了根本改变，那么是不是先得准备好保护模式所需要的寻址资料呢。</p><h3 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h3><p>其实在准备寻址资料之前还需要一步叫屏蔽中断，保护模式下的中断和实模式下的可不一样，所以为了安全第一步就得屏蔽实模式下的中断，指令如下</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="准备全局段描述符"><a href="#准备全局段描述符" class="headerlink" title="准备全局段描述符"></a>准备全局段描述符</h3><p>然后得准备好全局段描述符 GDT用来存放实模式下的CS和IP的段地址信息；</p><p>接下来得有一个指向GDT的寄存器，它叫 GDTR寄存器 初始化这个值使其指向GDT基地址。</p><h3 id="设置CR0"><a href="#设置CR0" class="headerlink" title="设置CR0"></a>设置CR0</h3><p>CR0也是CPU的寄存器之一，它可以控制CPU的重要特性，其中有一个位置就是代表了是否进入保护模式，是它的最低位——保护允许位，将这个位设置成1，就代表要开启保护模式。</p><h3 id="长跳转"><a href="#长跳转" class="headerlink" title="长跳转"></a>长跳转</h3><p>设置完CR0之后，就开始进入保护模式了，这个时候得需要长跳转指令，如下，</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">jmp 08h:_32bits_mode<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么是长跳转？<br>长跳转的一个作用是可以清空CPU的指令流水线，在切换到保护模式前，有很多实模式下的指令进入到了指令流水线中，而这个时候CPU又切换了工作模式，就得把之前的指令都清空。</p><p>长跳转到08h这个地址执行，这个时候cs的值也就被重新赋值了。</p><h3 id="初始化相关寄存器"><a href="#初始化相关寄存器" class="headerlink" title="初始化相关寄存器"></a>初始化相关寄存器</h3><p>长跳转完之后，最后就是进行相关寄存器的初始化，比如ax、bx、sp等，初始化完之后就按照保护模式的寻址方式进行寻址。</p><p>到此，CPU进入了保护模式运行，完了模式切换。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>回顾上面的内容，主要讲解了实模式的一些历史起源、寻址原理，以及保护模式下的几个概念和寻址方式，最后对两种模式的切换步骤做了描述，你可能有疑问了，是不是还有64位的工作模式，没错，是还有64位的工作模式——长模式，它的寻址原理和32位差不多，也是会有一个段描述符来存储信息，只是在校验方面有些不同，弄懂保护模式就很好理解长模式了。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> Liunx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Liunx启动，你想知道的全都在这!</title>
      <link href="/2021/11/10/os-liunx-start/"/>
      <url>/2021/11/10/os-liunx-start/</url>
      
        <content type="html"><![CDATA[<p>Liunx是我们日常学习工作中，打交道最多的一个系统，似乎我们很少关注它的启动初始化，那么本文就带你捋一捋Liunx启动初始化那些事。</p><p>全文结构大致如下：首先会讲解一些基础知识，这为你阅读本文减小一些压力，然后会从整体启动流程上带你简要梳理一遍Liunx启动，然后会分开深入到各个阶段去彻底理解每个阶段在干什么，之后为了检验自己是否大致掌握Liunx启动，我会以问答的形式留下几个问题，最后会对全文启动流程做一个简单的总结。</p><p>话不多说，先来几个问题热热身</p><h1 id="那些你会迷惑的问题"><a href="#那些你会迷惑的问题" class="headerlink" title="那些你会迷惑的问题"></a>那些你会迷惑的问题</h1><ul><li>为什么开机的时候是从BIOS里的代码开始执行而不是内存或外存里的？</li><li>0xFFFF0这个地址存在于哪里？</li><li>BIOS到底又做了些什么</li><li>为什么一开始只有1M的寻址空间？</li><li>为什么需要有GRUB引导程序，不要它行不行？</li><li>我们能调用fork并创建出系统的第一个进程吗？</li><li>ps -ef 里面有很多父进程是1，这个1号进程是啥？</li><li>…..</li></ul><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>下面是两点基础知识，阅读前，回忆一下，话不多说，上图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127085544.png"></p><ul><li>计算机是由CPU、内存、磁盘、IO设备等硬件组成，其中在运行前，操作系统会将我们的二进制程序加载到内存中，这个时候才能被CPU运行。CPU就会去内存中读取相关的指令。需要注意一点的是：<strong>CPU只能读取内存中的指令，它不能和磁盘等这类外存设备交互。</strong></li><li>CPU分为三个单元：计算、控制、数据单元，其中数据单元主要由一些寄存器组成，主要存储运行过程中产生的值，控制单元就是控制从哪里读取指令并控制计算单元去算，计算单元很好理解了，就是做苦力，给我算！！！，而CPU取代码指令是由CS（代码寄存器）和IP（指令寄存器）共同完成的，CPU会改变这两个寄存器的值，然后控制单元通过地址总线来到相应的内存地址取值。</li></ul><p>好了两点基础知识回忆完了，进入正题！</p><h1 id="启动整体流程"><a href="#启动整体流程" class="headerlink" title="启动整体流程"></a>启动整体流程</h1><p>老规矩，先上图，一目了然，这张图描述了启动的几个阶段，其中前面三个红色阶段是重点。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127090033.png"></p><p>上图大致解读：当机器通电后，整个机器就开始运行了，最先来到的是BIOS时期，这个时候CPU控制权在BIOS手里，会进行开机自检，自检完了之后会 会查找可启动设备，加载主引导目录（MBR），加载完MBR之后，将CPU的控制权转交给了GRUB引导，经过GRUB的几个引导步骤之后，GRUB完成就加载了内核代码，接下来，内核就会接管CPU控制权并完成接下来的内核初始化启动任务。内核初始化完成最后会运行sbin/init进行系统的初始化，等系统初始化完了之后会启动终端，输入密码，就完成了一次启动，整个流程大致就是这样了。</p><p>下面我们深入各个阶段来看看，每个阶段具体干了些什么。</p><h1 id="深入各阶段分析"><a href="#深入各阶段分析" class="headerlink" title="深入各阶段分析"></a>深入各阶段分析</h1><h3 id="BIOS-时期"><a href="#BIOS-时期" class="headerlink" title="BIOS 时期"></a>BIOS 时期</h3><p>首先是 BIOS 时期阶段，BIOS（Basic Input and Output System，基本输入输出系统）系统程序在厂家出厂的时候被固化在了一个叫 ROM（Read Only Memory）的东西上，它是一个只读的存储器，显然这是一个只能读取，不能写入的存储器。了解完 BIOS 是被固化的程序之后，你肯定好奇，BIOS 程序是如何被找到的？</p><p>其实这得多亏了 CPU 设计的硬件程序员们在设计 CPU 时已经将特定的值写好了。</p><p>通电之后，CS 寄存器和 IP 寄存器会被强制赋值，其中 CS 被设成：0xFFFF，IP 设成 0x0000。在前缀知识，我们了解到了 CS 寄存器是代码段寄存器，全称是 Code Segment，它存放的是内存代码段区域的段基址。IP 寄存器是指令寄存器，全称是 Instruction Pointer，他存放的是下一条要执行指令的段内偏移地址。</p><p>有了段基址和段内偏移地址，我们就能得到下一条程序的地址。在 8086 16 位处理器中为了兼容 20 根地址总线的寻址能力，就将 cs 寄存器左移四位 + ip 寄存器 = 下一条程序地址。例如：cs = 0xFFFF， IP = 0x0000，计算出来的地址 address = CS &lt;&lt;&lt;&lt; 4 + IP = 0xFFFF0。</p><p>这里 CPU 本身只能处理 16 位数据，如果超过了 16 位，比如 18 位 0000 0000 0000 0001 00 那么就超出了 cpu 的处理范围，但是地址总线有 20 跟， 也就是可以传输 20 位的数据 例如 0000 0000 0000 0001 0001，那么 16 位和 20 位怎么兼容呢？CPU 工程师们就想到了 讲 cs 寄存器左移四位在加上 ip 寄存器的值不就是 20 位了吗？这个计算方法就是这么来的。看图，一目了然。</p><p>有框相加 就是最终值 20 位了。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127090156.png"></p><p>通过 CS 寄存器和 IP 地址得到的内存地址 0xFFFF0，属于连接了主板的 ROM 芯片上，这类芯片的寻址方式和内存 RAM 是一样的，也就是上面提到的 BIOS 程序固化在上面了。</p><p>CPU 拿到 0xFFFF0 这个地址，就跳转到这里来执行 BIOS 代码，BIOS 就开始执行起来了。这个 0xFFFF0 地址是在 ROM 上，这和 X86 架构下 CPU 实模式工作原理有关，X86 系统会将 0xF0000 到 0xFFFFF 这 64K 空间映射给 ROM 上，而 0x00000 ~ 0xDFFFF 这段空间映射给 RAM。所以其实最开始内存没有初始化的时候，是从 ROM 读取的 BIOS 程序，具体内存布局看下图：</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127090206.png"></p><p>你仔细一看就知道了 0xFFFF0 落在了 倒数第二上面的 ROM 区域。</p><p>那么 BIOS 系统做了什么呢？</p><p>首先 BIOS 会进行 CPU，内存的初始化工作，这个时候我们说的 8G 16G 内存就真正初始化完了，可以用了。然后会把自己的一部分复制到内存中去，这一步就是为了以后建立中断向量表和服务程序做准备以及把相关的启动区程序加载进去，最后跳转告诉 CPU 跳转到内存去执行代码，这个跳转地址是：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">jmp far f000:e05b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到会跳转到 0xfe05b（cs=0xf000 + ip=0xe05b =&gt; cs &lt;&lt;&lt;&lt; 4 + ip = 0xfe05b） 执行内存中的代码，这也是最早内存中的代码。<br>跳转到内存之后，会进行本地设备的初始化工作，并进行检查，看看硬件是否损坏等，这个时候 BIOS 就会开始调用显卡、网卡等烧写好的固件程序了。</p><p>以上都完成好之后，还会建立一个中断向量表和中断服务程序，我们用到的鼠标和键盘都是要通过中断实现的，这也是启动 Liunx 非常重要的工作。</p><p>做完中断的初始化工作，下一步就是准备加载引导程序了。</p><p>为了能够启动外部存储器中的程序，BIOS 会搜索可引导的设备，至于按照什么顺序搜索，这些都是在出厂芯片中设定好了的，可以是从硬盘中、U 盘中、网络中等等。</p><p>当然，一般都是从硬盘中启动的。硬盘上的第一个扇区，512 个字节的大小，这也是每个扇区的标准大小，被称为 MBR（Master Boot Record，主启动记录），这个里面包含三个重要的信息，如图：</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127090220.png"></p><ul><li>引导加载程序（Boot loader) 446 字节</li></ul><p>存储操作系统相关的信息，比如名称、内核位置等等。</p><ul><li>分区表 64 字节</li></ul><p>也就是磁盘分区了，每个主分区占 16 个字节，</p><ul><li>分区表有效性标记 2 字节</li></ul><p>BIOS 会把 MBR 加载到内存中执行，这个执行地址是 0x7c00，也就是说把主启动记录程序 MBR 全部加载到从 0x7c00 这个开始地址中了，为什么是 0x7c00 这么一个奇怪的地址呢？这是由于 IMB 公司最早的个人电脑 IBM PC6160 上市的时候搭载操作系统是 86-DOS，用到的芯片是 Intel 的第一代个人电脑芯片 8088，86-DOS 操作系统运行时需要的内存至少是 32KB，32KB 的范围就是 0x0000 ~ 0x7FFF，而 8088 本身需要占 0x0000 ~ 0x03FF 来保存中断向量表和中断服务程序，所以还剩 0x0400 ~ 0x7FFF 给操作系统用，为了尽可能的将多的连续内存空间留给 86-DOS，MBR 被放到了内存地址的末尾，而 MBR 本身也会产生数据，所以最后计算方式就变成了 最高地址 0x7FFF + 1 - 512 -512 = 0x7c00 这里 +1 是因为取值是从 0 开始。</p><p>到这里 BIOS 的任务完成了，把控制器交给 MBR，Liunx 中是 GRUB 了。</p><h3 id="GRUB-引导"><a href="#GRUB-引导" class="headerlink" title="GRUB 引导"></a>GRUB 引导</h3><p>GRUB 全称叫全称 Grand Unified Bootloader Version。顾明思议就是搞系统启动的，当前都是用 GRUB2 了。这里为了简便就交 GRUB 吧</p><p>GRUB 的配置，我们可以在 /boot/grub2/ 目录下查看 grub.cfg，例如：</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">### BEGIN /etc/grub.d/10_Linux ###menuentry 'CentOS Linux (3.10.0-1160.45.1.el7.x86_64) 7 (Core)' --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option 'gnulinux-3.10.0-514.26.2.el7.x86_64-advanced-59d9ca7b-4f39-4c0c-9334-c56c182076b5' &#123;load_videoset gfxpayload=keepinsmod gzioinsmod part_msdosinsmod ext2set root='hd0,msdos1'if [ x$feature_platform_search_hint = xy ]; then  search --no-floppy --fs-uuid --set=root --hint='hd0,msdos1'  59d9ca7b-4f39-4c0c-9334-c56c182076b5else  search --no-floppy --fs-uuid --set=root 59d9ca7b-4f39-4c0c-9334-c56c182076b5filinux16 /boot/vmlinuz-3.10.0-1160.45.1.el7.x86_64 root=UUID=59d9ca7b-4f39-4c0c-9334-c56c182076b5 ro crashkernel=auto   net.ifnames=0  idle=halt console=tty0 console=ttyS0,115200n8 LANG=en_US.UTF-8initrd16 /boot/initramfs-3.10.0-1160.45.1.el7.x86_64.img&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是一个启动项，如果 grub 引导加载完成后，会让你选择操作系统，在那个选择菜单的界面就是这里配置而来的。<br>GRUB 引导启动阶段主要包含三个阶段，同时也分成了多个文件，两个重要的文件：boot.img 和 core.img，</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127090243.png"></p><p>话不多说，上图。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG215_20211127090322.png"></p><p>下面来具体看看这两个文件是怎么样被加载的。</p><p>boot.img 主要在 1 阶段被加载。</p><h4 id="Stage1-阶段"><a href="#Stage1-阶段" class="headerlink" title="Stage1 阶段"></a>Stage1 阶段</h4><p>这个阶段 BIOS 时期最后跳转的入口地址程序——BootLoader。</p><p>由于 512 个字节实在太有限了，它做不了太多的事情。仅仅就加载了 boot.img。</p><p>而 boot.img 的一个位置写入了 core.img 的文件位置，类似于你去问路，某大爷告诉你应该怎么怎么走，这个时候 boot.img 就相当于这位大爷了。</p><p>boot.img 之后就跳转 core.img 入口地址，开始进入 Stage1.5 阶段了</p><h4 id="Stage1-5-阶段"><a href="#Stage1-5-阶段" class="headerlink" title="Stage1.5 阶段"></a>Stage1.5 阶段</h4><p>这个阶段是 Stage1 和 Stage2 之间的过渡步骤，主要是加载 Stage2 阶段用到的 core.img，core.img 包含 diskboot.img、lzma_decompress.img、kernel.img 和一些列模块。</p><p>这个阶段首先会加载 diskboot.img，这个文件中以文件块列表的方式保存着 core.img 这个文件内容，所以 diskboot 能够找到 core.img 剩下的内容并将其他的内容加载进来，在这阶段主要是做让系统具有识别文件的能力，也是一个从 Stage1 到 Stage2 的过渡期。</p><h4 id="Stage2-阶段"><a href="#Stage2-阶段" class="headerlink" title="Stage2 阶段"></a>Stage2 阶段</h4><p>这个过程主要是执行上面 Stage1.5 阶段存放的加载指令，主要是 core.img 的解压文件和内核文件。在解压加载 kernel.img 之前，lzma_decomprees.img 会调用 real_to_prot，从实模式切换到保护模式。为什么要做这一步骤呢，因为实模式下的 1M 空间实在太小了，寻址不到超过 1M 的地址，而内核加载到内存中大于 1M 了，所以得寻求更大的空间。就会切到保护模式下，这样就能有更大的寻址空间，加载更多的东西了，保护模式下是 32 位寻址空间，也就是 2^32B = 4G，这也就足够寻址到内核在内存中的地址了。</p><p>所以 CPU 工作模式从实模式到保护模式的切换就是在 GRUB 引导阶段进行的。</p><p>有了更大的寻找空间之后，就会对 Kernel.img 进行解压缩，然后跳转到 Kernel.img 开始执行，这个时候会开始读取 grub.cfg 文件里的配置信息。如果启动正常，最后就会显示出让你选择操作系统的列表画面。</p><p>当你选择完操作系统之后，grub 的任务也就要完成了，这个时候就开始加载内核代码，也就开始进入到下一阶段了。</p><p>内核初始化阶段就真正来到了操作系统层面了，这里就是操作系统程序启动的入口！！！</p><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><p>内核初始化主要分为三个部分，也就是 0、1、2 三个进程的建立三部分，首先 grub 引导 Liunx 内核加载完之后，从 start_kernel() 方法开始进行内核初始化，这个方法非常有名，因为这里是内核的开始，Liunx 的入口。</p><h4 id="著名的-start-kernel"><a href="#著名的-start-kernel" class="headerlink" title="著名的 start_kernel()"></a>著名的 start_kernel()</h4><p>来看 start_kernel() 中的代码，这里删除了很多代码，这个方法有 200 多行，主要是一个包装方法，里面调用了各个部分的初始化方法，这里选取了几个比较重要的方法，稍作说明。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">void start_kernel(void)&#123;        //零号进程初始化    set_task_stack_end_magic(&amp;init_task)    //中断门初始化    trap_init();    //内存初始化        mm_init();    ftrace_init();    //调度器初始化    sched_init();    //fork初始化建立进程的     fork_init();        //VFS数据结构内存池初始化      vfs_caches_init();    //运行第一个进程     arch_call_rest_init();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="万物之源——0-号进程"><a href="#万物之源——0-号进程" class="headerlink" title="万物之源——0 号进程"></a>万物之源——0 号进程</h4><p>首先我们来看看万物之源——0 号进程</p><p>0 号进程的初始化代码</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">set_task_stack_end_magic</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>init_task<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到这句初始化需要传入一个 init_task 参数，来看看这个 init_task 怎么来的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* Initial task structure */</span><span class="token keyword">struct</span> task_struct init_task <span class="token operator">=</span> <span class="token function">INIT_TASK</span><span class="token punctuation">(</span>init_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">EXPORT_SYMBOL</span><span class="token punctuation">(</span>init_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过了一个叫做 EXPORT_SYMBOL 的宏进行的初始化。<br>这个宏里面主要是对 init_task 做了写死赋值，所以我们的 0 号进程的信息，都来源是硬编码！！！这就是道生一呀。</p><p>可以看到这个结构是 task_struct，它是个什么东西呢？</p><p>顾名思义，task 是任务，也就是任务结构，任务？ 好像和我们 CPU 执行任务有点联系。</p><p>没错！ 它就是 CPU 执行任务的结构，也是表示进程和线程的数据结构。具体的解读请期待下一期。这里我们紧扣主题——Liunx 启动。</p><p>好了 0 号进程有了，也就是 万物之源的 一 出来了。接下来内核会做更多的初始化，例如：</p><ul><li>中断模块初始化 trap_init()</li></ul><p>这个方法里面设置了很多中断门，用于处理各类中断，BIOS 时期也建立了中断向量表和服务程序，没错这里会根据之前建立的，为操作系统重新建立一次。</p><ul><li>内存模块初始化 mm_init()</li></ul><p>这个方法里面会初始化内存管理模块，内存是这个时候才开始被操作系统初始化的，在操作系统层面要使用内存，就必须在这个之后了。</p><ul><li>调度模块初始化 sched_init()</li></ul><p>这个方法会初始化调度模块，主要是用于 CPU 调度任务。</p><ul><li>fork 创建初始化 fork_init()</li></ul><p>fork 在这里才被初始化，未被初始化之前都无法使用 fork，1 号进程的初始化也是在 fork 之后进行的。所以我们 0 号进程是无法通过 fork 进行初始化的。</p><ul><li>文件系统初始化 vfs_caches_init()</li></ul><p>这里会初始化基于内存的文件系统 rootfs,文件系统是存储信息的，要兼容各类文件系统，系统会抽象出一层虚拟文件系统（VFS Virtual File System）.</p><ul><li>其他初始化 rest_init()</li></ul><p>这里会做很多其他方面的初始化工作，比如 1 号、2 号进程的初始化。</p><h4 id="1-号进程建立"><a href="#1-号进程建立" class="headerlink" title="1 号进程建立"></a>1 号进程建立</h4><p>1 号进程是在 rest_init() 方法里调用 kernel_thread(kernel_init, NULL, CLONE_FS) 进行的初始化，它对于操作系统来讲有着很重要的意义，可以说是“标志性划时代的”，在 1 号进程没有初始化的时候，所有资源都是操作系统内核本身的，而 1 号进程初始化完之后，要讲一些资源分配给它进行使用。这也就从改变了系统的运行方式。这里就设计到了，有哪些资源是内核所可以调用的，哪些资源是给类似 1 号用户进程调用的，x86 架构给我们提供了权限机制，就很好的解决了这个问题，这里简单提一点：内核拥有 Ring0 最高权限，我们把关键的资源和代码放在这里，也叫做内核态，而普通用户程序放在 Ring3，也叫做用户态。他们之间是通过系统调用进行沟通的，话不多说，看图，从里往外权限依次降低，可以看到内核态具有最高权限。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG216_20211127090345.png"></p><p>1 号进程的建立，CPU 的执行权限，将会从内核态转到用户态。在 1 号进程建立时，是调用下面的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ramdisk_execute_command<span class="token punctuation">)</span>    ramdisk_execute_command <span class="token operator">=</span> <span class="token string">"/init"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是这个 ramdisk，进行了用户空间的初始化，从虚拟根文件系统切换到真正的根文件系统。<br>这一部分主要是通过在内存中建立虚拟根文件系统实现相关设备的驱动并建立和切换到真正的根文件系统。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/WechatIMG217_20211127090419.png"></p><p>如上图，我们当前在 / 目录下，也就是根文件目录， 它的功能就是讲内核与真正的根建立联系，内核通过它加载根文件系统的驱动程序，然后以读写方式挂载根文件系统，在 initrd 程序建立 ramdisk 内存虚拟根文件系统后 内核开始驱动基本硬件，例如：CPU，I/O 等等，在驱动加载完后，会根据 grub.cfg 文件中的 root=”xxxxx”指定的内容创建一个根设备，可以往上面看 grubp 配置文件里有下面这段代码。</p><pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">set root='hd0,msdos1'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后将跟文件系统以只读的方式挂载，这就切换到真正的根文件系统上了。这也就是 ramdisk 的作用。<br>1 号用户进程初始化完了，用户进程的祖先有了，那么内核进程的祖先还没，你可能会有疑惑，我们的 0 号进程不就是内核进程吗？对没错，但是 0 号进程后续会变成 CPU 的 idle 进程，要另作他用。idle 进程，你可以理解为 CPU 不工作时，他就开始运行的一个进程，他的主要作用是：节能和低退出延迟。所以得创建一个 2 号进程来作为所有内核态的祖先。</p><h4 id="2-号进程建立"><a href="#2-号进程建立" class="headerlink" title="2 号进程建立"></a>2 号进程建立</h4><p>2 号进程是调用 kernel_thread 方法创建的，其具体方法如下</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">kernel_thread</span><span class="token punctuation">(</span>kthreadd<span class="token punctuation">,</span> NULL<span class="token punctuation">,</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 号进程是用来管理内核态的线程调度，是所有内核线程的祖先<br>2 号进程初始化完，到目前用户态和内核态都有祖先进程管理了，系统初始化也完成了。</p><p>2 号进程完成后会调用/sbin/init 程序，开始进入系统初始化阶段。</p><p>到这里， 内核就加载完成，接下来就是对整个系统进行初始化。</p><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p>经过了内核的初始化，系统其实已经跑起来了，已经可以开始运行程序了，但是为了更好的提供给用户使用，需要对一些常用的东西进行封装成服务，以进程的形式加载进来。</p><p>系统初始化阶段首先会通过/etc/inittab 进行运行级别的确认，运行级别是为了系统的允许而定的机制，下面例举了 7 种级别：</p><p>0、关机，shutdown</p><p>1、单用户模式，这个就是 root 用户，最高权限；</p><p>2、多用户维护模式，会启动网络功能，但不会启动 NFS</p><p>3、多用户完全功能模式，文本界面，这个是默认的运行级别</p><p>4、预留级别：目前无特别使用目的，但习惯以同 3 级别功能使用；</p><p>5、多用户完全功能模式，图形界面，与 3 不同的是这是图形化界面模式；</p><p>6、重启，reboot</p><p>然后会去执行系统初始化脚本/erc/rc.sysinit，为用户初始化用户空间，完成之后，根据运行级别，系统开启对应的服务，关闭那些不要的服务。</p><p>系统初始化脚本主要做的一些事：设置 host 名和欢迎信息、挂在/etc/fstab 定义的文件系统、设置系统时钟、加载额外设备的驱动程序等等。</p><p>系统的初始化工作主要执行这个脚本程序，到此系统就进行了正常的初始化。</p><h3 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h3><p>默认运行级别情况下，会打开 6 个纯文本终端，这是 Liunx 设定的。</p><p>系统初始化完成后，会给出相应的用户登录提示，用户输入密码后，系统调用 login 程序，核验密码，如果正确，会分配 uid 和 gid，这两个 id 用于检测用户的身份信息，之后就从文件 /etc/passwd/读取登录用户指定的 shell 并启动。</p><p>到这里，整个系统就启动好了！！</p><p>接下里看看最上面提到的几个问题</p><h1 id="几惑问题"><a href="#几惑问题" class="headerlink" title="几惑问题"></a>几惑问题</h1><ul><li>为什么开机的时候是从BIOS里的代码开始执行而不是内存或外存里的？</li></ul><p>内存是需要进程初始化之后才能使用，而内存初始化是在 start_kernel 方法才进行，所以开机通电就读内存的代码是不行的。而文章中提到了 CPU 是不能和外存打交道的，所以开机读外存的代码也是不可行的。由于 BIOS 的代码是存放在 ROM 中的，在 CPU 运行的时候与内存 RAM 相似，</p><p>所以 CPU 开机的时候可以在这里读取代码。</p><ul><li>0xFFFF0这个地址存在于哪里？</li></ul><p>回答完上面那个问题，相信，你也知道了，0xFFFF0 这个 BIOS 入口地址是在 ROM 中了。</p><ul><li>BIOS到底又做了些什么？</li></ul><p>在上面 BIOS 时期中已经提到了它做的一些事，可以参考上面。</p><ul><li>为什么一开始只有1M的寻址空间？</li></ul><p>当前 CPU 有三种工作模式， 实模式，保护模式，长模式，最开始的时候 CPU 处理实模式下，也就对应在最早的 8086CPU 工作模式，而这个模式下虽然处理数据的位数只有 16 位，但是地址总线有 20 位，20 位的地址总线的寻址空间有 2^20B = 1M 这么大，这也就是最开始的寻址空间大小了，后面随着 CPU 的工作模式切换，这个寻址空间也变大了。</p><ul><li>为什么需要有GRUB引导程序，不要它行不行？</li></ul><p>这个问题和上个问题也有牵连，由于最开始的寻址空间只有 1M，所以无法直接一次加载操作系统内核那么大的程序，如果将超过 1M 的空间地址加载到内存中，而这是能够获取到内存的最大地址是 1M， 1M 以后的数据都获取不到，所以得一步步引导并扩大，最后全部加载进来。</p><p>整个 Liunx 的启动，就像重定向一样，BIOS 告诉 CPU 你去 加载 GRUB，而 GRUB 告诉 CPU 我是启动引导程序，用户选择完操作系统后，你就可以进行加载了，而且我还要切换你的工作模式。</p><p>就这样一步步引导，Liunx 就初始化完成了。</p><ul><li>我们能调用fork并创建出系统的第一个进程吗？</li></ul><p>通过上面的讲解，想必你也能回答这个问题了，fork 是系统调用，需要在操作系统内核初始化之后才能调用，比如 1 号进程就是 fork 出来的。</p><ul><li>ps -ef 里面有很多父进程是1，这个1号进程是啥？</li></ul><p>阅读完全文，想必你也知道了这个 1 就是 1 生万物 的 1，由于有了 1 号进程，用户态下的所有进程的鼻祖，它的作用不言而喻。</p><h1 id="简要总结"><a href="#简要总结" class="headerlink" title="简要总结"></a>简要总结</h1><p>本文从 Liunx 系统的启动初始化，与你一起了解了计算机启动原理，一起深入理解了 BIOS 时期，它干的一些事情，以及 GRUB 引导程序的相关知识，还有根据 Liunx 源码解读了内核初始化过程，最后回答了文章开头提出的相关问题。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> Liunx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《程序员的自我修养》导读</title>
      <link href="/2021/10/16/books-study-xiuyang/"/>
      <url>/2021/10/16/books-study-xiuyang/</url>
      
        <content type="html"><![CDATA[<p>今天来和大家分享《程序员的自我修养————链接、装载与库》这本书的全书导读，它在去年我拿下微信、抖音、百度等大厂sp以级上offer有非常大的帮助，分享与你，希望能够对你带来启发。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在工作之余，重新认真阅读学生时代读过的书籍，阅读到了这本对我秋招帮助很大的书，重新思考了一些原来读这本书时的问题，比如：windows系统相关知识，我到底要不要精读？一些晦涩难懂的知识该怎么办？等等，所以打算梳理一篇该书的导读内容，希望对你能够有所帮助。<br>PS：如果你还没有读过本书，建议你去认真阅读本书，你肯定能收获不小。</p><h1 id="阅读前所需要具备的基础知识"><a href="#阅读前所需要具备的基础知识" class="headerlink" title="阅读前所需要具备的基础知识"></a>阅读前所需要具备的基础知识</h1><p>下面为你整理了，你阅读本书前，最好所具备的前言知识，这样能够在你阅读的时候减少很多阅读障碍。如果你缺少一些前言知识，也没关系，努努力，啃一啃，遇到问题时，去努力解决，也会有不小收获。</p><ul><li>C/C++编程语言基础</li><li>汇编语言基础</li><li>操作系统基础</li><li>计算机组成原理基础</li></ul><h1 id="全书概览"><a href="#全书概览" class="headerlink" title="全书概览"></a>全书概览</h1><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB_20211127132746.png"></p><p>如上图所示，全书分为四个部分。<br>第一部分：温故而知新<br>第二部分：静态链接<br>第三部分：装载与动态链接<br>第四部分：库与运行库</p><h1 id="章节概览"><a href="#章节概览" class="headerlink" title="章节概览"></a>章节概览</h1><p>下面是一些章节的概览，有些知识Windows的知识也不需要去完全掌握，毕竟我们可能很少接触windows开发吧。<br>第一章：温故而知新<br>本章也就是全书概览上的第一部分，主要介绍一些背景知识和阅读本书的一点铺垫知识，比如：CPU、内存等硬件，操作系统进程、线程相关知识。<br>第二章：编译和链接<br>本章主要介绍基本的编译概念以及编译几大过程还有链接器相关知识。<br>第三章：目标文件<br>本章介绍了Windows和Liunx量大系统的目标文件，回答了目标文件是什么，目标文件类型，目标文件如存储等问题。<br>第四章：静态链接<br>本章主要讲解静态链接基础知识和静态链接基本步骤和过程，还讲解举例了最“小”链接。<br>第五章：Windows PE/COFF<br>本章介绍Windows平台的目标文件和可执行文件。<br>第六章：可执行文件的转载与进程<br>本章通过介绍进程的基本概念，地址空间布局等知识引申出了可执行文件的加载过程。<br>第七章：动态链接<br>本章主要讲解Liunx系统下的.so动态库的动态链接过程。<br>第八章：Liunx动态库<br>本章主要详解介绍动态库的相关知识，包括动态库的分布和组织等。<br>第九章：Windows下的动态链接<br>这章主要讲Windows下面的动态链接机制<br>第十章：内存<br>这章主要讲运行时内存相关知识，包括堆与栈，堆的分配算法，函数调用栈等。<br>第十一章：运行库<br>这章主要介绍运行库的概念、c/c++运行库、Glibc和MSVC CRT相关知识。<br>第十二章：系统调用与API<br>这章主要讲系统调用知识，包括系统调用流程以及相关API介绍。<br>第十三张：运行库实现<br>这章主要实现了一个支持堆、基本文件操作等功能的Mini CRT.</p><h1 id="导读建议"><a href="#导读建议" class="headerlink" title="导读建议"></a>导读建议</h1><p>通常阅读一本书，我们会有一个问题：我需要从书中得到一些什么？可能是已有知识的总结回顾、也可能是新知识的获取。不管怎么样，我们会有想要得到的收获，那么阅读《程序员的自我修养》这本书，你能得到什么呢？</p><ul><li>以CPU会为核心回顾计算机体系知识</li><li>了解代码编译的基本概念和步骤</li><li>Liunx系统下目标文件格式以及如何存储</li><li>静态链接基本概念，为什么要有静态链接</li><li>目标文件如何被静态链接到一起行程可执行文件</li><li>静态链接时的空间地址分配、符号决议和重定位如何进行</li><li>可执行文件如何被系统加载，与进程的地址空间如何映射</li><li>动态链接基本概念以及链接时相关问题</li><li>运行时的内存分配以及入口程序初始化<br>上面是一些基本能得到的收获，我们从中抽象为三个重要问题：</li><li>源码是如何被编译成可执行程序的？</li><li>可执行程序是如何被加载到内存的？</li><li>内存中的进程空间布局是怎么样的？</li></ul><p>带着这个三个问题，去阅读本书，效果会更好。首先我们从书本脉络出发，尝试回答第一个问题</p><h3 id="源码是如何被编译成可执行程序的？"><a href="#源码是如何被编译成可执行程序的？" class="headerlink" title="源码是如何被编译成可执行程序的？"></a>源码是如何被编译成可执行程序的？</h3><p>这个涉及相关编译问题，从上面的章节概览可以得到，在第二章：编译和链接就能找到相关答案，所以你需要认真阅读第二章全部内容，不过这里只稍微展开讲了编译的大致过程，但是生成可执行文件还需要链接，所以顺着下去需要搞懂链接。<br>那么在学习链接之前，书本第三章：目标文件里面有什么，就讲解了需要链接的输入产物长什么样子，以及链接前的基本知识：链接的接口（基本单位），所以第三是一个基础知识，是为后面章节做铺垫的，你需要大致清楚目标文件的基本知识，第三章也是需要全部认真阅读的。<br>接下来就是链接了，第四章：静态链接，本章首先根据目标文件，讲解了两种链接方法，之后讲解了链接的两个步骤，然后引申出C++的相关问题，其次讲解了静态库的链接，最后有一个小实验，让你动手体验。<br>到这里你很好的回答上面的这个问题了。<br>接下来我们继续下一个问题。</p><h3 id="可执行程序是如何被加载到内存的？"><a href="#可执行程序是如何被加载到内存的？" class="headerlink" title="可执行程序是如何被加载到内存的？"></a>可执行程序是如何被加载到内存的？</h3><p>回答完前面那个问题后，你了解了可执行程序的文件内容以及格式，前文开篇提到需要由操作系统的基础知识，操作系统知识中程序运行的基本单位是进程，可执行程序加载到内存肯定首先需要了解进程的地址空间，其次需要知道是以上面方式加载到内存的。在加载到内存之前需要进行进程的建立等操作，所以在本书第六章主要为你解答这些问题。<br>认真理解静态链接之后，我们会有一个疑问，那些在静态链接没有被重定位的符号怎么办？符号表里都是存在的偏移地址，那真实地址如何确定。这就涉及到了动态链接了，在静态链接没有完成的工程，由程序加载时进行动态链接完成。本书在第七章详细介绍了动态链接的相关知识，包括步骤实现、懒加载等等。<br>在了解完动态链接之后，还需要了解动态库的特性，所以在第八章介绍了Liunx下动态库相关的知识。<br>读完前面八章内容，你已经非常熟悉编译链接加载相关知识了。<br>那么加载完了之后是运行，所以接下来一个问题就是关于运行的了。</p><h3 id="内存中的进程空间布局是怎么样的？"><a href="#内存中的进程空间布局是怎么样的？" class="headerlink" title="内存中的进程空间布局是怎么样的？"></a>内存中的进程空间布局是怎么样的？</h3><p>进程的空间布局直接影响会影响程序的运行，运行时也需要用到一些堆、栈等空间，所以在本书第十章讲解了内存相关知识，包括进程的空间布局、栈与调用惯例、堆与内存管理等知识，读完本章，你能够大致明白，程序运行时的一些地址是怎么回事。<br>程序运行你肯定好奇入口，也就是计算机是如何进入执行程序的。那么本书第十章：运行库，第一节为你讲解了相关知识。<br>读到这里你对于计算机的编译、链接、加载、运行有了很深刻的认识，从全局层面进行了系统性的学习。</p><p>回答完三个问题，接下来对本书的内容做一个小小的总结</p><h3 id="导读总结"><a href="#导读总结" class="headerlink" title="导读总结"></a>导读总结</h3><p>p1-109，建议精读，读懂读透，读完就能系统的计算机编译链接相关知识。<br>P127，使用ld链接脚本，本节需要自己动手尝试，计算机是一门工科，多动手体会。<br>P149-175，讲解可执行文件的转载和进程，需要精读。<br>P179-P219，讲解动态链接，这一部分内容稍有难度，需要花些精力认真读。<br>P229-P248 讲解动态库，如果动态链接有些吃力，这一章可跳过也不影响。<br>P283-334，这一部分就需要回到上面的第三个问题了，也需要认真弄懂。</p><p>整体下来前面175页的知识读下来会比较轻松，同时也能掌握很多的知识，从动态链接开始难度有会有提升了。但是只有理解了动态链接，你才能理解程序编译链接时给动态链接留下接口是为什么，当然你也可以大致把动态库理解为一堆功能代码的共享。导读总结就到这里了，希望你读完有所收获。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正如这本书的取名一样，程序员也需要由自身的技术修养，在自我修养这条路上，笔者和大家一起成长。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 书籍导读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双非本科成功上岸BAT大厂，大学四年我经历了些什么？</title>
      <link href="/2021/09/20/ex-my-university/"/>
      <url>/2021/09/20/ex-my-university/</url>
      
        <content type="html"><![CDATA[<p>首先，解释一下什么是双非，通俗易懂，两个不是，既不是985高校，又不是211高校。本科也就是本科学历，至于是本一还是本二，其实差别不大，至少差别不那么离谱。要肯定一点的是：双非有机会能进入BAT这类大厂，但是难度也大。拿自己身边举个例子，周围大学同学进大厂的很少，一个科班计算机院也就那几个同学进入BAT大厂，从这些同学身上发现有一个共同的特点：努力且不服输。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那双非的本科如何才能进BAT这类大厂呢？ </p><p>答案显而易见：首先你得努力，其次你得掌握方法，总结学习技巧，然后你得抓住机会。有人会跟你说：”学习编程天赋最重要”，请不要听他瞎说！请不要听他瞎说！！请不要听他瞎说！！！学习编程，通过面试，进入大厂，这一过程远远、远远、远远不到要拼天赋的地步（这里是指通过努力进入大厂，不指大学期间的一些ACM算法竞赛）。</p><h1 id="编程入门的摸爬滚打"><a href="#编程入门的摸爬滚打" class="headerlink" title="编程入门的摸爬滚打"></a>编程入门的摸爬滚打</h1><p>拿我自己的亲身经历来说，大一上学期学校实验室招新，c语言入门的第一个程序：Hello,world 都学了大半个月，学了就忘、忘了又学，反反复复。在那些认为需要天赋的同学眼中这应该属于天赋很差了吧。我也开始自我怀疑，是不是不适合学习编程？是不是自己天赋不够？是不是自己太过于愚笨？现在来看，至少可以肯定的是：我能够努力学习并且成功通过BAT大厂的面试进入到这个行业中，并且实习1年多，工作也较顺利。回到Hello,world学习！通过大半个月的摸索，我发现了自己的问题：学习方法不对，我仅仅是看书本上面的表面知识，然后死记硬背的把格式背下来，</p><p>#include&lt;stdio.h&gt; ……</p><p>根本没有理解程序是怎么运行的，为什么要这么写，include背后又发生了什么？所以大半个月的学习都是在瞎折腾，我开始去百度一些相关讲解，尝试去理解为什么要这么写，后来我放弃了，因为我根本看不懂他们讲解的CPU通过PC寄存器读取指令，又怎么通过总线传递数据。</p><p>后来我又跑去问室友，他是怎么理解的，他的答案告诉我：当前也没理解这么多，先记忆下来，慢慢写程序多了会理解的吧。这回我又有信心了（编程入门的时候结伴学习是一个很好的学习方法，自己如果一个埋头苦干，很容易陷入自我怀疑）。<br>最后顺利的通过了实验室的最后一轮初试面试，赶上了末班车。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/1331632702887_.pic_hd_20211127133916.jpg"></p><p>但是进入招新训练营之后，又开始慢慢自闭了。每周训练题不会做，全靠百度看题解写题，周末训练赛排名垫底水平，极大的打击了我的信心。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/1341632702917_.pic_hd_20211127133928.jpg"></p><p>又开始陷入自我天赋的怀疑了，开始反思，为什么其他人可以很快地将训练题做完，又可以很好的适应周末训练赛，于是我开始观察晚上自习的时候，旁边的人都在干什么，我发现旁边的人也在做非常基础题目，比如打印三角形之类的。我发现旁边的人也跟我一样，基础没打好，就开始做较难的算法题，没开始走就开始跑了，当然你会跑不快，也跑不远，甚至跑不动。所以我开始补基础题了，从基础题出发，一步一步掌握相关知识，有一次在课堂上又让我重新找回来了自信，老师提问了一个GCD的问题，大家都在思考鸦雀无声，我很快写出来了，其中有一个数据防止溢出的细节被老师表扬，于是自信又回来了，原来大家都一样都不会而已，就这样一边补基础一边做周训练题。慢慢地找到了编程感觉了,于是后来也顺利的进入了实验室学习，在有一次比赛上还拿了第一名。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/1351632702937_.pic_hd_20211127133941.jpg"></p><p>回过头来看那一段招新训练营的时光，因为是纯算法，又是刚刚入门编程，非常容易打击人的自信，又迫于被淘汰的风险，压力也大。也很容易产生厌烦情绪，因为本身做算法题是枯燥的，大部分人在一开始很难顺风顺水地对待它。后来加入实验室没有再选择ACM校队继续做算法题，深知自己天赋不足。到现在也非常佩服那些在ACM算法竞赛上付出超于常人的努力，最后取得不错成绩的同学。</p><p>有很多学弟学妹会来问我，该怎么样去掌握编程知识，因为自己经历过那些坑坑洼洼，都建议从前端开始入手，至少前端入手，会让你感觉到有成就感，不会像算法那样一头雾水还很枯燥。</p><p>所以这样一个没有天赋、又没有学校背景的渣本科班，肯定是不能进入大厂了吧。但是大学四年的努力下来，最终看到了希望，也成功抓住了希望，最后上岸了。</p><h1 id="迷茫的大一"><a href="#迷茫的大一" class="headerlink" title="迷茫的大一"></a>迷茫的大一</h1><p>大一上学期都是在学校的实验室招新集训队度过的，上面也提到了，直到寒假也在不停学习一些c的基础知识和算法。 </p><p>大一下学期因为顺利加入实验室了就轻松了也就比较放飞了，在寝室和室友一块玩吃鸡，还立下了不吃鸡不睡觉的flag，后来还直接在晚自习实验室打游戏，追剧。</p><p>每天浑浑噩噩的过着，后来醒悟过来，这样下去不行，加入实验室并不是终点，应该好好利用实验室的资源学习起来，好好学习，当初压根不敢想我们那个学校出来的能进入BAT这类大厂。后面在大一下学期就努力学习，努力把数据结构的基础打好。也接触和尝试各个方向的编程技能。</p><h1 id="坚定的大二"><a href="#坚定的大二" class="headerlink" title="坚定的大二"></a>坚定的大二</h1><p>经历过了大一迷茫，在大一末尾，和同学组队参加了一个Apple举办的iOS移动开发大赛，很遗憾地没能进入决赛，但是获得了夏令营的资格，于是和同学在暑假一起来到了浙江大学参加夏令营，全程免费，四星级酒店住宿, 体验非常好。非常感谢我的一位学长，给了我很多帮助，包括后来找实习都给了很多建议。浙大，这是我高中一直梦想考上的大学，可惜只是梦想，来到浙大以后许下了一个愿望，三年后来这里读研（当即就买了19年王道考研408全套）。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/1371632702996_.pic_hd_20211127134003.jpg"></p><p>事与愿违，三年多过去了，我也没有去到那里读研，而是选择了走入社会大学修炼。经过了夏令营的学习，格局、见识都打开了不少，认识了很多其他高校的同学，了解到他们在做什么，差距在哪里，也成为了大二坚定选择iOS开发深入学习的重要原因。<br>于是大二就开始坚定的选择了iOS移动开发，在iOS移动开发这一路上也是坑坑不断，不过因为在算法上踩过的坑，很好的锻炼了自己的编程耐力，借有位老师的话。</p><p>“学计算机，搞编程，一定要耐得出寂寞”。</p><p>因为全校没有人做iOS，没有老师懂iOS，第一位在我们学校做iOS的同学就是上面提到的那位15级学长，18年那一年，他正在字节跳动实习。所以iOS开发学习的路上只能单枪匹马了，也没有人能够及时解答自己的一些问题，对比同实验室的学安卓的同学会有学长亲自指导，不过好在有一位实验室的同学一起搞iOS，一个人走得快，两个人走得远，后来我们两成为了非常好的挚友。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127134357.png"></p><p>大二这一年还成为了实验室移动开发小组的组长，成为指导大一新生学习的学长，也成为了新生们眼中那个很强的学长，深知自己还很菜，为了对得起学弟们的期待，于是大二上学期，像拼命了一样在实验室疯狂学习，早上8点之前准时到，晚上通过10：30之后 才回宿舍。这样的生活在每一个没有课的日子和每个周末必定出现，甚至还带着女朋友一起去实验室学习！！！（直男本男）。</p><p>有人会好奇这样一天天在实验室学习咋还有女朋友，也是非常偶然的机会，在下一届新生工作上认识的她，后来大二下学期，我们分手了，是那个传说中的恋爱会影响学习的理由。</p><p>为了更好的参加Apple 举办的那个比赛， 要涉及开发一整个APP，从idea到产品原型到设计搞，到程序开发，到上架，到部署，这一整条链路要花费我非常多的时间，因为心思都在编程上，自然也会影响两个人之间的关系，后来就演变成了分手。</p><p>大学最重要的就是大二这一年，度过了大一的迷茫，也没用大三、大四的压力，可以放手干一些自己喜欢的事，去做那些有意思的事情，经过大二的一年摸索，对未来也会更加清晰。</p><p>下图是18年年底写下的总结<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127134424.png"></p><h3 id="动摇的大三"><a href="#动摇的大三" class="headerlink" title="动摇的大三"></a>动摇的大三</h3><p>我是选择考研呢(学校太差，没有保研资格)，还是选择面试参加工作呢。后来我沿用了18年年底写下的两条路策略。</p><p>一手准备面试，一手准备考研，先投简历面试，如果能进BAT这类大厂，那就放弃考研。</p><p>因为考研的知识408 是和面试重合的，所以就从408开始下手，两手抓，如果你在大三比较动摇，那你也可以 跟我一样两手抓，既不耽误考研，也不耽误面试，面试不顺就掉头开始做数学题，准备考研。</p><p>这里需要注意就是给自己一个面试期限，当初我给自己定的是4月20。也就是春招实习，如果4月20还没能找到实习，那就放弃，开始做数学题。距离12月20考研刚好还剩8个月，对付数学、英语，自己全力以赴，也不会差很多。</p><p>数据结构与算法是我最早开始复习的知识，大三上学期才开始学操作系统、计算机网络等课，大三上的课也很多，所以数据结构与算法的一些书籍，在上课的时候去复习，时间会利用得比较好，不上课的时候就在寝室做一些算法题，按照《剑指offer》这本上的题一个个解决。数据结构与算法是程序的基石，也是面试必定会问到的，也是其他知识的基础，就从他开始下手了。</p><p>计算机网络、操作系统、计算机组成原理等这类计算机体系知识，就把吃灰很久的王道考研拿了出来，开始做题，复习，总结。</p><p>因为疫情，似乎大三过得非常非常快，在面试的时候，跟双非同学找工作遇到的问题一样：前期简历被拒，被捞起来刷KPI一面挂。非常打击人的自信。又如同大一那会开始慢慢自闭了。。自我反问，双非面试大厂真的有这么难嘛？我为什么这么菜，自闭总归要过去，还是要向前看，于是我告诉自己要稳住心态。开始查漏补缺，一步步复习，到了4月初终于拿到了一个快手的offer，也放 下了心，就安安心心去实习吧。</p><p><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/image_20211127134435.png"></p><p>有一个自己坚信的点是：如果能去大厂实习，首先争取在实习的时候转正，其次在参加其他公司的秋招，有过大厂实习经历了也不至于简历被疯狂拒绝那么惨痛，所以决定不考研了。</p><h1 id="初入社会的大四"><a href="#初入社会的大四" class="headerlink" title="初入社会的大四"></a>初入社会的大四</h1><p>在快手实习3个月之际，拿到了字节跳动抖音的秋招提前批offer，一路面试下来非常顺利，在快手实习过了，加成非常大！因为字节跳动是我所有公司中最想去的公司，这也是算是小小的圆梦。于是很快就从快手离职，回家修整。半个月之后，我正式踏上了实习的大四之旅。大四过程中一直在实习，也就是公司里的一些事情，后续会做一次专门的分享，在字节的工作感受。</p><p>到这里，我的大学结束了，时间很快，收获也很大。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大学四年，我像大多数人一样谈过恋爱，逃过课，打过游戏，我也和很多人一样努力学习进到了自己想去的公司。也从Hello world 都要学半个月的那个菜鸡，到拿到微信，抖音、百度、美团等大厂offer的”offer收割机”，所经历的一切，都离不开自己的努力，更加 离不开运气，如果没有认识那位15级学长的，可能连大厂的门槛都够不着，又或者是另外一种风景。</p><p>However, 大学四年给了我一个让自己满意的结果。</p><p>更多内容你可以关注公众号： 「<strong>ConeZhang</strong>」<br><img src="https://cone-pic.oss-cn-beijing.aliyuncs.com/pic/poster.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保持页面滑动流畅性的一次工程实践</title>
      <link href="/2020/03/30/iOS_UI_fps/"/>
      <url>/2020/03/30/iOS_UI_fps/</url>
      
        <content type="html"><![CDATA[<p>最近在做自己的独立App的时候又出现到了UItableView的滑动流畅性问题，于是这一次想彻底的解决这一问题，并总结解决方法，待以后工作开发中可以快速复用，提高效率。<br> 界面滑动流畅一般是指系统会在一秒钟之内刷新60次界面，也就是60FPS（Frames Per Second）,即每16.7ms就需要刷新一次，如果每次刷新时间超过16.7ms，就会出现界面掉帧和卡顿，就会让用户感觉到滑动不流畅，会带来非常不好的体验。追求性能、提升用户体验是我们开发者永远期待并执行的一件事。</p><p> 先来看看现状吧，剖析完现状才能对症下药。</p><h3 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h3><p><img src="http://120.77.154.242/images/20200617/f0n4UvAY1ewMuX97jHzE.png"><br> 可以看到FPS有出现了20、30多的情况，这已经到了无法接受的的地步了。所以开始优化实践吧。期望值能稳定达到55~60，也就是使滑动达到或接近满帧。</p><h3 id="了解原理"><a href="#了解原理" class="headerlink" title="了解原理"></a>了解原理</h3><p> 在做性能优化之前，去了解原理是必不可少的一个过程，熟悉并理解原理之后，我们才能做出更加成熟、稳定的优化方案。</p><h5 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h5><p> 还记得我们物理学中的电子枪、电子在磁场中的运动等知识，也就是这些基础的物理知识成就了现在的高科技电子产品。<br> 显示器中有两个同步信号用来控制电子枪。水平同步信号（HSync）和垂直同步信号（VSync）。其中水平同步信号会控制电子枪进行扫描换行，也就是同步好一帧画面的绘制工作，垂直同步信号则是用来控制帧与帧之间的同步，避免出现上一帧还没有绘制完就开始了下一帧的绘制工作。<br> 通常来讲，一帧画面的绘制，需要CPU和GPU来共同完成，其中CPU将会计算好需要显示的内容提交给GPU，而GPU会进行渲染工作，渲染完成后会提交到帧缓冲区中，随后视频控制器会根据VSync信号读取帧缓冲区中的数据，经过数模转换传递给显示器进行显示。</p><h5 id="UI卡顿原因"><a href="#UI卡顿原因" class="headerlink" title="UI卡顿原因"></a>UI卡顿原因</h5><p> 开篇的时候也提到了一点点原因，不过在这里较详细的提及一下。<br> 在绘制一帧画面的时候的时间轴节点是以VSync信号来进行的。当Vsync信号到来之时，系统会发出通知，告诉App主线程可以开始进行工作了，这时候CPU开始进行计算需要显示的内容，比如视图的创建、计算布局、图片解码、文本绘制等任务，随后将计算好的结果通过总线提交给GPU，有GPU进行变换、合成、渲染，随后GPU将渲染的结果提交到帧缓冲区，等待视频控制器读取显示。由于垂直同步的机制，如何CPU和GPU在一个VSync信号的时间内没有完成上述工作并没有提交到帧缓冲区。那么这一帧就会被丢弃，等待下一个VSync信号到来在读取，那么屏幕上面的内容将会保持不变，这就是卡顿的原因。</p><h3 id="寻找切入点"><a href="#寻找切入点" class="headerlink" title="寻找切入点"></a>寻找切入点</h3><p> 从原理背后我们可以发现，我可以从CPU和GPU做的工作进行入手进行优化，那么先来看看CPU和GPU具体做了哪些工作。</p><h4 id="CPU干了些什么"><a href="#CPU干了些什么" class="headerlink" title="CPU干了些什么"></a>CPU干了些什么</h4><h5 id="对象的创建与初始化调整"><a href="#对象的创建与初始化调整" class="headerlink" title="对象的创建与初始化调整"></a>对象的创建与初始化调整</h5><p> 在面向对象的编程世界里，视图显示的时候缺了对象怎么能行。CPU第一步工作就是需要创建好这次视图显示所需要的对象了。而创建对象需要分配内存、调整属性、有些还会涉及到一些文件读取初始化操作，这里就会消耗CPU资源。在创建好对象之后的初始化调整时也是非常消耗CPU资源的，我们熟知的CALayer：它内部并没有属性，当调用属性方法的时候，它内部通过OC强大的运行时机制，调用resolveInstanceMethod为对象临时添加一个方法，并能把把属性保存起来。</p><h5 id="视图布局（AutoLayout）"><a href="#视图布局（AutoLayout）" class="headerlink" title="视图布局（AutoLayout）"></a>视图布局（AutoLayout）</h5><p> 我们知道AutoLayout在iOS12之前如果在进行自动布局的时候没有把握好，消耗的CPU资源与时间会层指数级增长（这点笔者有幸看过一篇博文，iOS中的Layout是利用的Cassowary算法进行线性规划，算法在进行计算完后会以一组线性方程组呈现出来，求解这组线性方程组就依赖其复杂度，在iOS12之前的某些情况下没有利用好改算法，使得线性方程组的复杂度非常高，就出现了指数级增长[笔者看完博文后的思考，如有错误欢迎留言指出~]）。视图布局不管是利用AutoLayout进行布局还是原始的frame布局，最终转化出来都是以UIView的frame、bounds等属性的调整上。</p><h5 id="文本的计算与内容渲染"><a href="#文本的计算与内容渲染" class="headerlink" title="文本的计算与内容渲染"></a>文本的计算与内容渲染</h5><p> 大多数情况下我们需要对某一个Cell里面的Text内容进行高度、宽度计算，而与计算有关的事情肯定是耗CPU的，所以这一点也会影响到我们的滑动流畅性。再来看看文本内容的渲染，熟知的屏幕上能看到的所有内容都是由一个个位图显示合成而来，我们的文本控件在底层都是通过CoreText排版、绘制成bitmap显示。可想而知排版和绘制都会使CPU的消耗。</p><h5 id="图片解码与图像绘制"><a href="#图片解码与图像绘制" class="headerlink" title="图片解码与图像绘制"></a>图片解码与图像绘制</h5><p> 当我们调用UIImage(named:”xxxx”)的时候，图片的数据并不会立刻解码，这里可以参考我写的<a href="www.baidu.com">SDWebImage解读心得</a>。在图像显示的时候可以说万物皆图像了，这里指的就是UIView里面的drawRect方法了。这个绘制方法如果是在主线程做的话也是会大量消耗CPU资源</p><h4 id="GPU干了些什么"><a href="#GPU干了些什么" class="headerlink" title="GPU干了些什么"></a>GPU干了些什么</h4><p> 在我们学习计算机组成原理的时候老师可能会讲到GPU最擅长的事情就是与图像有关了，在计算机视觉的世界中GPU当然也是非常重要的。它做的事情相对于CPU来讲，比较专注于一件事：将CPU提交过来的结果，进行渲染、合成最终提交给屏幕帧缓冲区。</p><p> GPU在提交位图到帧缓冲区之前将会做:纹理渲染、视图合成、图形生成等工作。先来看看纹理渲染，纹理渲染是指所有的Bitmap都要由内存提交到显存，在这一提交过程中都是有GPU负责，避免不了消耗GPU资源。然我们在一个Cell里面加载大量图片的时候，CPU占有率很低，而GPU非常高，也会出现卡顿掉帧的情况。<br> 视图的合成，当我们把多个View叠加到一起的时候回发生什么呢？当然是消耗GPU资源了，在多个View混合合成的时候需要尤其是当顶层View的alpha值不为1的时候，这个时候就会进行像素叠加计算，如果视图混合过多，那么像素的叠加计算时间就会边长，从而影响性能。<br> 图形的生成是指CALayer的一些属性可能会发生离屏渲染，而离屏渲染通常发生在GPU中,会新开劈一个屏幕缓冲区(非当前屏幕缓冲区)这样需要消耗资源和时间。</p><h3 id="提出解决方案"><a href="#提出解决方案" class="headerlink" title="提出解决方案"></a>提出解决方案</h3><h4 id="1、减轻CPU压力"><a href="#1、减轻CPU压力" class="headerlink" title="1、减轻CPU压力"></a>1、减轻CPU压力</h4><p> 如何减轻CPU压力，那么根据项目现状，我想计算时间方面入手。</p><h5 id="提前计算"><a href="#提前计算" class="headerlink" title="提前计算"></a>提前计算</h5><p> 提前计算好Cell所有需要的数据高度，在进行刷新的时候保证在O（1）的时间内取出。</p><h5 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h5><p> 图片显示的时候我们可以将其异步到子线程中进行解码加载，不阻塞主线程的正常工作。</p><h5 id="减少计算"><a href="#减少计算" class="headerlink" title="减少计算"></a>减少计算</h5><p> 在使用Autolayout的时候，我们尽量不要依赖于同级视图进行布局计算，这样可以保证局部同级视频的优先级是统一的，从而不需要延长布局时间。</p><h4 id="2、减轻GPU压力"><a href="#2、减轻GPU压力" class="headerlink" title="2、减轻GPU压力"></a>2、减轻GPU压力</h4><p> 减轻GPU压力主要可以从 图像合成的时候规避不必要的离屏渲染和规避不必要的alpha值的使用。</p><h3 id="落地"><a href="#落地" class="headerlink" title="落地"></a>落地</h3><p> 提前计算O（1）时间内取出高度<br> <pre class="line-numbers language-none"><code class="language-none">func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;    let data &#x3D; viewModel.momentDatas[indexPath.section].comments[indexPath.row]    return data.height&#125;func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -&gt; CGFloat &#123;    let data &#x3D; viewModel.momentDatas[section]    if data.contentHeight &gt;&#x3D; 250.fitW &amp;&amp; data.conntentIsFold &#123;        return data.height + 250.fit - data.contentHeight    &#125;    return data.height&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p> 异步解码：<br> swift中的Kinshfier与OC中间的SDWebImage已经帮我们做了。可以去了解弄清其中的原理。</p><p> 减少计算：在updateCell的时候利用一个 sumHeight 表示距离Cell顶部的距离，为参数进行布局。<br> <pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 如此类布局        contentLabel.snp.remakeConstraints &#123; (make) in           make.top.equalTo(self).offset(sumHeight)            make.height.equalTo(contentHeight)            make.left.equalTo(self).offset(20.fitW)            make.width.equalTo(screenWidth - 40.fitW)        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p> 在GPU这块，由于笔者的项目没有出现需要加入aplha值，所以没有进行调优。</p><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><p> 能稳定达到55帧率，不影响用户体验。</p><h3 id="未来可以继续研究"><a href="#未来可以继续研究" class="headerlink" title="未来可以继续研究"></a>未来可以继续研究</h3><p> 1、重写UIView的drawRect方法 进行异步绘制<br> 2、可以利用贝塞尔曲线进行圆角的控制。<br> 3、利用runloop空闲时间进行预缓存。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年小结——余生，请不留余力地学习。</title>
      <link href="/2019/12/30/2019_summary/"/>
      <url>/2019/12/30/2019_summary/</url>
      
        <content type="html"><![CDATA[<p> 不知道从什么时候开始，喜欢上了一些东西，现在也想紧紧地拥抱这些自己喜欢的东西，可似乎又有一些东西是触不可及了。2019这一年，经历了很多事情，让我一步步成长。如果有人问我2019你最大的收获是什么，我想我会毫不犹豫地回答：余生，请不留余力地学习。<br> 这句话让我明白了自己真正想要达到的彼岸不是某喜欢高校的研究生通知书，也不是某想去大厂的offer，而是一直不断地学习，充实自己，做那些自己喜欢的事情，追寻人生的意义。</p><h2 id="关于孤独"><a href="#关于孤独" class="headerlink" title="关于孤独"></a>关于孤独</h2><p> 2019这一年，我懂得了孤独，说到孤独，我想我应该讲到了队友东哥，当我孤独而不想学习的时候，会跟队友东哥聊聊人生，聊聊比赛，聊聊技术。这一年里，与东哥一起在实验室里度过，一起比赛，中国设计大赛上我们做过并肩战斗的队友，移动应用赛上面 我们各自带队厮杀，他很厉害，他也很懂孤独，我欣赏他那份对朋友的真诚与对孤独的态度。他从不去教室上课而是天天泡实验室学习（还能拿奖学金），而我会去上上课，为了节约时间多写几行代码，多思考几个问题，中午或者晚上的时候 一句东哥，带饭，不用讲什么菜，他就会带我喜欢的。我们是很好的队友、朋友。2019年这一年，在iOS开发这条路上，他与我一起学习，很幸运地有这样一位队友一起泡在实验室里学习。为什么说我自己懂得了孤独，还是会扯回到前面出现的她，因为某种关系，暑假来到了上海实习，虽然住在亲戚（很亲）家，大概还是非常孤独吧，偶尔心里还会想起她，也没有同龄人一起，于是就在思考孤独是什么，时间慢慢地走过，也似乎慢慢的懂了，原来孤独是常态，也是我们人生的一种心境，要学会享受孤独。于是我说，2019年我也理解了孤独，要学会享受孤独。于是在孤独之下，2019我也做了很多其他事情。也有了不小的进步。</p><h2 id="关于进步"><a href="#关于进步" class="headerlink" title="关于进步"></a>关于进步</h2><p> 2019这一年，依旧没有忘记高考那时的那份不满，仍然朝着自己心中的彼岸前行。我知道这一路有很多阻碍，但是如果不朝着心中那份光奔跑，人生的意义也许就不知道是什么了吧。<br> 比赛<br> 2019年的几个比赛是我进步最大，也是最促使我进步的，首先是大学生创新创业项目的申报，我的大创项目是一个基于情感分析的记录类型的app，通过写大创的文档，规范格式，我的文档能力有了很大的提升，为我后面地比赛写文档也打下了基础，这个项目申报很顺利，是一个省级的项目，目前app也已经快要开发完了。<br> 接下来要提到的是中国设计大赛，那个时候我的作品还么有成型，队友东哥的作品差不多了，于是我跟他组队参加了比赛，暑假我们也来到了安徽师范大学进行决赛。最后我们获得了三等奖。然后想提到的是互联网+参加校赛，没过。这也让我有了一定的商业知识。因为需要进行商业计划书的编写。然后是移动应用创新赛，这个比赛是最锻炼到我的，因为队友的设计水平很高，设计稿一出来，我就恨不得马上实现，于是开始很有热情的做这样的事。暑假我们去到了apple设计开发加速器，这里我见识到了Apple的各类大佬，真的是非常大佬，膜拜。10月份 我们到了浙大进行了决赛，最后又是三等奖，我很生气吧，评委都没有来展台深入了解我的作品，就凭10分钟的答辩决出。于是很气馁的拿了三等奖，论设计，开发能力，我们团队都不差…却只拿了三等奖，于是明年我还想来。最后伴随着移动应用赛的结束，2019的比赛完结了。收获了很多很多，认识了浙大，福州大学，同济大学等很多学校的同学，格局和见识真的都不一样。我不想做一名坐井观天的青蛙呀，我得跳出来，看看他们。向他们学习。</p><h2 id="关于实习"><a href="#关于实习" class="headerlink" title="关于实习"></a>关于实习</h2><p> 暑假，因为某种关系，我来到了上海某家公司实习，iOS开发实习，体会到了 带薪自习，由于对实习生要求不高，师傅给了我一个项目，我去熟悉了整个实习期，虽然在技术水平上没有明显提升，但是我还是有很大对收获，对业务流程，对企业了解都有很大的收获。实习期间遇到的同事也非常好。整个实习下来，最大的收获就是上面提到对懂得了孤独，其次是我想要的人生是什么样子的。由于是带薪自习，能力没有明显提升，下面提到的二面面试官问我有没有实习经历过，都不好说出来有过。<br> 移动应用赛之后，我的大厂投简历找日常实习计划也开始了。11开始了我的复习准备面试。<br> 很感谢某学长的内推12月面试完了字节跳动，面试官都非常好，一面面试官在最后做算法题的时候我多用了一个变量，还提醒我可以少一用一个，二面面试官要我问了他三四个问题。hr面的hr姐姐聊得很来。后面hr告诉我面试都过了，目前在跟我申请offer，某学长说，实习offer一般不会被刷，如果不出很大意外的话，1月份我就要踏上深漂的道路了。很期待ing。面试字节跳动地收获不在于我想拿到实习offer，而是我知道了我自己很多地方的不足，要自己好好去弥补。收获真的非常大。 也让我更加坚信余生，请不留余力地学习 这句话的绝对正确。</p><h2 id="关于收获"><a href="#关于收获" class="headerlink" title="关于收获"></a>关于收获</h2><p> 参加了很多比赛也获得了一些荣誉，记录一下吧，也是年度总结呢。<br> 第十届蓝桥杯省级二等奖<br> 第十二届中国计算机设计大赛三等奖<br> 第四届中国计算机大赛移动应用创新赛三等奖<br> 2019学年 校级二等奖学金、三好学生。<br> 互联网+校赛 三等奖<br> 2019大学生创新训练计划省级项目<br> 第七届数媒大赛全国一等奖<br> 荣誉大概都是虚的，自己能力提升才是真的。这也是2019年我收获的一点。自己的能力才是最重要的，其他都是虚的，不要虚荣，不要那些虚的东西，能力不行都会一票否决。</p><h2 id="展望吧！"><a href="#展望吧！" class="headerlink" title="展望吧！"></a>展望吧！</h2><p> 2020，我想好好努力，好好沉淀自己的技术。那个2019年遇见的不可能的人，也许是有缘无份吧。我想2020年，也要做好准备去遇见可能的她。努力变优秀，之后慢慢遇见。<br> 余生，请不留余力地学习。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 内存管理ARC 以及循环引用思考</title>
      <link href="/2019/11/09/Swift-arc/"/>
      <url>/2019/11/09/Swift-arc/</url>
      
        <content type="html"><![CDATA[<p>内存管理是编程时一个不可回避的问题，在Swift中，是自动管理内存的，也就是ARC机制，自动引用计数机制。我们不需要关心内存的申请和分配。</p><h4 id="ARC工作机制"><a href="#ARC工作机制" class="headerlink" title="ARC工作机制"></a>ARC工作机制</h4><p>当我们每次创建一个类的新实例的时候，ARC会为我们分配一块内存来存储实例的信息。当该实例不在被使用时即一个实例没有引用的时候，ARC会为我们释放掉所占用的内存，也就是即使清除内存，不造成内存泄露。</p><p>如果我们正在使用的实例被ARC回收掉。当我们在此访问的时候会造成崩溃。为了保证真正使用的实例内存不会被回收，ARC会跟踪和计算每一个实例被引用的数量，如果不为0，就不会销毁或回收。</p><p>如果想要我们的实例不会被销毁，我们需要创建该类实例的强引用。</p><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当两个对象相互强引用对方的时候，其中都不能被释放，就出现了循环引用</p><pre class="line-numbers language-none"><code class="language-none">class Person:NSObject&#123;    var name:String    init(name:String) &#123;        print(&quot;\(name) 被初始化&quot;)        self.name &#x3D; name    &#125;    var car:Car? &#x3D; nil    deinit &#123;        print(&quot;\(name) 被释放&quot;)    &#125;&#125;class Car:NSObject&#123;    var id:String    init(id:String) &#123;        print(&quot;\(id) 被初始化&quot;)        self.id &#x3D; id    &#125;    var person:Person? &#x3D; nil    deinit &#123;        print(&quot;\(id) 被释放&quot;)    &#125;&#125;        var james:Person? &#x3D; Person(name: &quot;James&quot;)        var bmw:Car? &#x3D; Car(id: &quot;湘B:88888&quot;)        james!.car &#x3D; bmw        bmw!.person &#x3D; james        &#x2F;&#x2F; James 被初始化        &#x2F;&#x2F; 湘B:88888 被初始化        james &#x3D; nil        bmw &#x3D; nil        &#x2F;&#x2F; 并未打印 James 被释放        &#x2F;&#x2F; 湘B:88888 被释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中就出现了循环引用，查找原因。两个对象相互强引用对方，导致谁都无法释放。也就james中间引用了bmw，而bmw中也引用了james,当我们尝试去释放james的时候，由于james的成员变量bmw无法被释放，导致自身也无法被释放。</p><h4 id="weak、unowned解决循环引用问题"><a href="#weak、unowned解决循环引用问题" class="headerlink" title="weak、unowned解决循环引用问题"></a>weak、unowned解决循环引用问题</h4><pre class="line-numbers language-none"><code class="language-none">weak var car:Car? &#x3D; nilweak var person:Person? &#x3D; nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们在两个类的成员变量前面加上 weak 关键字，很顺利的得到了我们想要的结果，两个实例被释放。</p><pre class="line-numbers language-none"><code class="language-none">james &#x3D; nilbmw &#x3D; nil&#x2F;&#x2F;  James 被释放&#x2F;&#x2F; 湘B:88888 被释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>weak：</strong> 当一个对象被声明为weak时，表示父层级对改对象没有指向，该对象的ARC 引用计数不会+1。当对象被释放后，弱引用也随即消失。继续访问改对象，程序会得到nil,不会引起崩溃。<br><strong>unowned：</strong> 它与weak的本质是一样的，不同点在于，对象被释放后，依然有一个无效的指向引用，它不是可选，也不是nil,继续访问改对象，会引起奔溃</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 写时复制机制 以及值类型与引用类型思考</title>
      <link href="/2019/11/09/Swift_cow/"/>
      <url>/2019/11/09/Swift_cow/</url>
      
        <content type="html"><![CDATA[<p>记录Swift语言特性–偶遇操作系统Copy on Write<br>今天在学习操作系统fork函数的时候遇到了写时复制，联想起了Swift中也有一个写时复制机制。</p><h3 id="Swift-写时复制"><a href="#Swift-写时复制" class="headerlink" title="Swift 写时复制"></a>Swift 写时复制</h3><pre class="line-numbers language-none"><code class="language-none">var a &#x3D; [1,2,3,4]var b &#x3D; a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当代码这样执行完的时候，数组a和数组b在内存上是同一块内容，也就是b目前还没有开辟新的内存，当 添加一条b.append(5) 并执行完之后，b和a在内存上就不是同一块内存了，系统给b新开辟了一块内存。即当b被复制但是还没有改变的时候，这时是没有发生新的内存开辟。</p><h3 id="值类型与引用类型思考"><a href="#值类型与引用类型思考" class="headerlink" title="值类型与引用类型思考"></a>值类型与引用类型思考</h3><p>Swift的类型分为两种：一种是值类型（如：Int类型），一种是引用类型（如：class类型），值类型在传递和赋值的时候是进行复制的，而引用类型则只会用一个指针指向这个对象，也就是内存中只存在一份。</p><h5 id="值类型："><a href="#值类型：" class="headerlink" title="值类型："></a>值类型：</h5><p>Swift语言在设计时，将struct、enum、String、Array这些类型都被设计成了值类型。这样做有什么好处？<br>一、线程安全：当新的线程对值类型进行访问的时候回copy出一份新的值，使用当线程会copy值类型内容时是线程安全的。<br>二、高效：在栈区进行操作相比于在堆区操作，更快速高效。<br>值类型在复制的时候也会产生额外的开销，但是Swift把这个开销控制在了最小范围内，也就是在没必要复制的时候，值类型不会进行复制。</p><h4 id="引用类型："><a href="#引用类型：" class="headerlink" title="引用类型："></a>引用类型：</h4><p>引用类型，即所有实例都共享一份数据。<br>在Swift中，除了class是引用类型，还有闭包也是引用类型。引用类型的复制是进行的浅拷贝，也就是复制了一份指向改对象的指针。指向一个对象的指针，其中任何一个对其内部数据改变的时候，其他对象的数据也会受到影响。</p><p>如果将引用类型声明为常量，意味着这个常量不能被同类型变量赋值修改，然而可以修改该常量指向的内存中的变量。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 使用总结</title>
      <link href="/2019/10/31/Git_used_summary/"/>
      <url>/2019/10/31/Git_used_summary/</url>
      
        <content type="html"><![CDATA[<p>从18年3月份接触iOS开发，使用git到现在快两年时间了，记录一次深入学习Git并总结。</p><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>Git是目前世界上最先进的分布式版本控制系统(没有之一)，是有liunx之父管理liunx版本用C语言编写的版本控制系统。</p><h4 id="集中式与分布式（SVN与Git）"><a href="#集中式与分布式（SVN与Git）" class="headerlink" title="集中式与分布式（SVN与Git）"></a>集中式与分布式（SVN与Git）</h4><h5 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h5><p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式最大的毛病是要联网才能工作，如果网路状况不好，提交一个文件需要很长时间，对于效率来讲，非常不友好。</p><h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>分布式版本控制系统没有中央服务器，每个主机都拥有一个完整版本库，如果A和B同时修了一个文件，只需要把修改的部分推送给对方即可。</p><h4 id="Git-常用命令使用"><a href="#Git-常用命令使用" class="headerlink" title="Git 常用命令使用"></a>Git 常用命令使用</h4><ul><li>git init 初始化仓库</li><li>git add readme.txt 把文件添加到仓库</li><li>git commit -m”添加了一个文件” 把文件提交到仓库</li><li>git status 查看仓库当前状态</li><li>git diff 查看修改内容</li><li>git log 查看历史提交记录 加上 –pretty=oneline参数</li><li>git reset –hard head^ 回退上一个版本， head~100 上100个版本 head^^ 上两个版本 其中Git内部有一个指向当前版本的HEAD指针，改变指针的指向即有速度快的特点。</li><li>git reflog 查看每一次（历史）命令</li><li>git checkout – readme.txt 撤回修改到最近一次git commit或者git add时的状态 – 重要，如果没有 命令的意思为 切换到另外一个分支</li><li>git reset head readme.txt 把暂存区的修改撤销掉。</li><li>git rm 删除一个文件</li><li>git push -u origin master 推送到远程仓库 第一次推送需要 -u</li><li>git remote add origin git@server-name:path/repo-name.git 关联一个远程库</li><li>git clone 从远程仓库克隆一个仓库</li><li>git checkout -b dev 创建并切换分支</li><li>git branch dev 创建分支</li><li>git checkout dev 切换分支</li><li>git branch 查看当前分支</li><li>git merge dev 将dev 分支合并到当前分支</li><li>git switch -c dev 创建并切换到dev分支</li><li>git switch master 切换到master</li><li>git branch -d dev 删除dev 分支</li><li>git log –graph命令可以看到分支合并</li><li>git branch -D <name>强行删除</li><li>git remote -v查看远程仓库的信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 将代码更优雅 —— 枚举</title>
      <link href="/2019/10/31/Swift-enum/"/>
      <url>/2019/10/31/Swift-enum/</url>
      
        <content type="html"><![CDATA[<p>笔者枚举在swift中真正站起来了，想来聊聊枚举，枚举跟其他类型一样在swift中属于一等类型。它有很多种用法，如果你读过Alamofire的源码，你会发现，枚举在这个库中得到了完美的诠释。</p><h3 id="enum的用法："><a href="#enum的用法：" class="headerlink" title="enum的用法："></a>enum的用法：</h3><h5 id="常规枚举"><a href="#常规枚举" class="headerlink" title="常规枚举"></a>常规枚举</h5><pre class="line-numbers language-none"><code class="language-none">enum Movement &#123;    case Left    case Right    case Top    case Bottom&#125;let aMovement &#x3D; Movement.Leftswitch aMovement &#123;case .Left:    print(&quot;left&quot;)default:    print(&quot;Unknow&quot;)&#125;if case .Left &#x3D; aMovement &#123;    print(&quot;Left&quot;)&#125;if .Left &#x3D;&#x3D; aMovement &#123;    print(&quot;Left&quot;)&#125;&#x2F;&#x2F; 整型enum Season: Int &#123;    case Spring &#x3D; 0    case Summer &#x3D; 1    case Autumn &#x3D; 2    case Winter &#x3D; 3&#125;&#x2F;&#x2F; 字符串型enum House: String &#123;    case ZhangSan &#x3D; &quot;I am zhangsan&quot;    case LiSi &#x3D; &quot;I am lisi&quot;&#125;let zs &#x3D; House.ZhangSanprint(zs.rawValue)enum CompassPoint: String &#123;case North, South, East, West&#125;let n &#x3D; CompassPoint.Northprint(n.rawValue)let s &#x3D; CompassPoint(rawValue: &quot;South&quot;)&#x2F;&#x2F; ....各种类型 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="非常规枚举"><a href="#非常规枚举" class="headerlink" title="非常规枚举"></a>非常规枚举</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;嵌套枚举enum Character &#123;    enum Weapon &#123;        case Bow        case Sword        case Lance        case Dagger    &#125;    enum Helmet &#123;        case Wooden        case Iron        case Diamond    &#125;    case Thief    case Warrior    case Knight&#125;let character &#x3D; Character.Thieflet weapon &#x3D; Character.Weapon.Bowlet helmet &#x3D; Character.Helmet.Iron&#x2F;&#x2F; 结构体枚举struct Scharacter &#123;    enum CharacterType &#123;        case Thief        case Warrior        case Knight    &#125;    enum Weapon &#123;        case Bow        case Sword        case Lance        case Dagger    &#125;    let type: CharacterType    let weapon: Weapon&#125;let sc &#x3D; Scharacter(type: .Thief, weapon: .Bow)print(sc.type)&#x2F;&#x2F;枚举值关联enum Trade &#123;    case Buy(stock: String, amount: Int)    case Sell(stock: String, amount: Int)&#125;let trade &#x3D; Trade.Buy(stock: &quot;Car&quot;, amount: 100)if case let Trade.Buy(stock, amount) &#x3D; trade &#123;    print(&quot;buy \(amount) of \(stock)&quot;)&#125;enum Trade0 &#123;    case Buy(String, Int)    case Sell(String, Int)&#125;let trade0 &#x3D; Trade0.Buy(&quot;Car0&quot;, 100)if case let Trade0.Buy(stock, amount) &#x3D; trade0 &#123;    print(&quot;buy \(amount) of \(stock)&quot;)&#125;&#x2F;&#x2F;枚举 函数enum Wearable &#123;    enum Weight: Int &#123;        case Light &#x3D; 2    &#125;    enum Armor: Int &#123;        case Light &#x3D; 2    &#125;    case Helmet(weight: Weight, armor: Armor)    func attributes() -&gt; (weight: Int, armor: Int) &#123;        switch self &#123;        case .Helmet(let w, let a):            return (weight: w.rawValue * 2, armor: a.rawValue * 4)        &#125;    &#125;&#125;let test &#x3D; Wearable.Helmet(weight: .Light, armor: .Light).attributes()print(test)enum Device &#123;    case iPad, iPhone, AppleTV, AppleWatch    func introduced() -&gt; String &#123;        switch self &#123;        case .AppleTV: return &quot;\(self) was introduced 2006&quot;        case .iPhone: return &quot;\(self) was introduced 2007&quot;        case .iPad: return &quot;\(self) was introduced 2010&quot;        case .AppleWatch: return &quot;\(self) was introduced 2014&quot;        &#125;    &#125;&#125;print (Device.iPhone.introduced())&#x2F;&#x2F; 枚举属性enum Device1 &#123;    case iPad, iPhone    var year: Int &#123;        switch self &#123;        case .iPad:            return 2010        case .iPhone:            return 2007    &#125;    &#125;&#125;let iPhone &#x3D; Device1.iPhoneprint(iPhone.year)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="枚举成员的遍历"><a href="#枚举成员的遍历" class="headerlink" title="枚举成员的遍历"></a>枚举成员的遍历</h4><p>有时候我们需要得到包含枚举所以成员的一个集合，这个时候就可以令枚举遵循 CaseIterable 协议。Swift 会生成一个 allCases 属性，用于表示一个包含枚举所有成员的集合。</p><pre class="line-numbers language-none"><code class="language-none">enum Beverage: CaseIterable &#123;    case coffee, tea, juice&#125;let numberOfChoices &#x3D; Beverage.allCases.countprint(&quot;\(numberOfChoices) beverages available&quot;)&#x2F;&#x2F; 打印“3 beverages available”&#x2F;&#x2F;也可以用for - in 进行遍历for beverage in Beverage.allCases &#123;    print(beverage)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 官方文档阅读笔记与思考（一）</title>
      <link href="/2019/10/31/Swift_doc1/"/>
      <url>/2019/10/31/Swift_doc1/</url>
      
        <content type="html"><![CDATA[<p>2019年12月20号，通过了字节跳动的iOS开发实习面试，二面面试官给我提了一个建议：把Swift经典著作再通读几遍，每一次都会有不同的收获，于是我想开始这个计划吧。</p><h4 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h4><p>swift非常鼓励我们使用常量，当我们非常确定一个量不会改变时，我们最好是使用let声明常量，这样就可以很好的降低出错几率，在实力开发过程中，当我们的一个var声明的变量而没有改变时，Xcode通常会对我们发出“从未改变”的警告。</p><h4 id="浮点数类型与整数类型"><a href="#浮点数类型与整数类型" class="headerlink" title="浮点数类型与整数类型"></a>浮点数类型与整数类型</h4><p>提到这个是因为，突然想到了一个问题，为什么在同一机器字长的机器上，浮点数存储数据的范围更大？</p><h4 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h4><p>Swift是类型安全的，在编译阶段会对代码进行类型检查并标记错误。那么Xcode如何实现编译时进行类型安全检查的？</p><h4 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h4><p>最接近Swift可选类型的是OC中间的类结构，OC类结构的nil表示缺少一个合法的对象，也就是什么都没有，而Swift将这一特性充分发挥好，将可选类型与Int,class等等类型全部结合起来，当我们不确定一个变量是否有值时，我们可以定义一个可选类型，例如：var a:Int?<br>浅尝探究可选类型底层如何实现：通过查看可选类型的源码可知道，可选类型是一个枚举结构(Swift语言设计真的将枚举推向了一个很高的地位）。</p><h4 id="基础运算符"><a href="#基础运算符" class="headerlink" title="基础运算符"></a>基础运算符</h4><p>Swift在设计的时候尽可能使得开发者在运行前检查出错误（感叹Swift的设计非常值得称赞，作者也是一名小小Swifter啦~），进行了很多非常令人舒适的设计，例如：如何我们进行条件判断的时候把 == 写成 = ，这时会报错，因为在C语言中 = 是有返回值的，这样会存在很多由于代码编写疏忽存在的问题（非常不必要的问题），而到Swift中， = 号没有返回值了，编译器进行类型检查的时候报错。<br>比较运算：Swift 标准库只能比较七个以内元素的元组比较函数。如果你的元组元素超过七个时，需要自己实现比较运算符。<br>逻辑运算:Swift 逻辑操作符 &amp;&amp; 和 || 是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。</p><p>总结：当自己被自己被各种各样的知识点困扰着的时候，静下心来再一次阅读官方文档真有着不一样的收货。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 将代码更优雅 —— 控制流</title>
      <link href="/2019/10/31/Swift-control_flow/"/>
      <url>/2019/10/31/Swift-control_flow/</url>
      
        <content type="html"><![CDATA[<h3 id="if-let-可选绑定"><a href="#if-let-可选绑定" class="headerlink" title="if let 可选绑定"></a>if let 可选绑定</h3><pre class="line-numbers language-none"><code class="language-none">var optionalName : String? &#x3D; &quot;Cone&quot;var greet &#x3D; &quot;hello!&quot;if let name &#x3D; optionalName &#123;   greet &#x3D; &quot;Hello, \(name)&quot;&#125;print(greet)&#x2F;&#x2F; Hello, Cone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码如何运行呢？如果变量的可选值为nil，条件会判断为false，大括号中的代码会跳过，如果不是nil，会将值赋给let后面的常量，这样代码快中就可以使用这个值了。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><pre class="line-numbers language-none"><code class="language-none">let vegetable &#x3D; &quot;red pepper&quot;switch vegetable &#123;case &quot;celery&quot;:    let comment &#x3D; &quot;celery&quot;;    print(comment)case &quot;cucumber&quot;, &quot;watercress&quot;:    let comment &#x3D; &quot;cucumber, watercress&quot;;    print(comment)case let x where x.hasSuffix(&quot;pepper&quot;):    let comment &#x3D; &quot;It is a \(x)&quot;;    print(comment)default:    let comment &#x3D; &quot;nothing&quot;;    print(comment)&#125;&#x2F;&#x2F; It is a red pepper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Swift中的switch语句支持很多种情况，包括枚举、范围、元组等等。</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where关键字在Swift中非常强大，谈谈使用场景。</p><h5 id="与switch-做限定使用"><a href="#与switch-做限定使用" class="headerlink" title="与switch 做限定使用"></a>与switch 做限定使用</h5><pre class="line-numbers language-none"><code class="language-none">let name &#x3D; [&quot;王二&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;]name.forEach &#123;     switch $0 &#123;    case let x where x.hasPrefix(&quot;王&quot;):           print(&quot;\(x)是笔者本家&quot;)    default: print(&quot;你好，\($0)&quot;)&#125; &#125;&#x2F;&#x2F; 输出:&#x2F;&#x2F; 王二是笔者本家&#x2F;&#x2F; 你好，张三&#x2F;&#x2F; 你好，李四&#x2F;&#x2F; 王五是笔者本家<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在-for中做限定"><a href="#在-for中做限定" class="headerlink" title="在 for中做限定"></a>在 for中做限定</h5><pre class="line-numbers language-none"><code class="language-none">let num: [Int?] &#x3D; [48, 99, nil]    let n &#x3D; num.flatMap &#123;$0&#125;for score in n where score &gt; 60 &#123;    print(&quot;及格啦 - \(score)&quot;)&#125;&#x2F;&#x2F; 输出:&#x2F;&#x2F; 及格啦 - Optional(99)        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="对协议扩展做条件限制"><a href="#对协议扩展做条件限制" class="headerlink" title="对协议扩展做条件限制"></a>对协议扩展做条件限制</h5><pre class="line-numbers language-none"><code class="language-none">extension Sequence where Self.Iterator.Element : Comparable &#123;public func sorted() -&gt;[Self.Iterator.Element]&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈Swift里面的闭包</title>
      <link href="/2019/10/31/swift_block/"/>
      <url>/2019/10/31/swift_block/</url>
      
        <content type="html"><![CDATA[<p>闭包是Swift中很重要的一点，也是难点。学习了Swift很久，记录一下对闭包的思考。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>1、闭包可以讲是一段代码的集合与函数类似，也是引用类型。<br>2、闭包的使用：主要用与回调（异步回调等等）<br>3、闭包可以作为函数参数传递等。<br>4、闭包表达式风格简洁，官方鼓励在一些常见的场景中进行语法优化，虽然在一定程度上会降低代码的可读性。<br>5、Swift的语法非常适合函数式编程的使用，而闭包正是函数式编程的核心概念之一了。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">&#123; (parameters) -&gt; return type in    statements&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>闭包表达式参数 可以是 in-out 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。</p><h3 id="几种类型"><a href="#几种类型" class="headerlink" title="几种类型"></a>几种类型</h3><h5 id="普通闭包"><a href="#普通闭包" class="headerlink" title="普通闭包"></a>普通闭包</h5><pre class="line-numbers language-none"><code class="language-none">let closure &#x3D; &#123;(x:Int) -&gt; Int in    return x*x&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h5><pre class="line-numbers language-none"><code class="language-none">func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123;    &#x2F;&#x2F; 函数体部分&#125;&#x2F;&#x2F; 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: &#123;    &#x2F;&#x2F; 闭包主体部分&#125;)&#x2F;&#x2F; 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() &#123;    &#x2F;&#x2F; 闭包主体部分&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们都知道闭包可以作为函数的参数，当我们最好一个参数为一个闭包表达式的时候，这个时候尾随闭包就出现了。<br>当一个闭包表达式很长，以至于不在一行编写的时候，尾随闭包就变得非常有用。<br>通过尾随闭包的语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在 某个函数function(_ : ) 方法的括号内</p><h5 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h5><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，这类型的闭包会在函数中逃逸。一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。</p><pre class="line-numbers language-none"><code class="language-none">var completionHandlers: [() -&gt; Void] &#x3D; []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;    completionHandlers.append(completionHandler)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h5><p>自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。简单来说 @autoclosure 做的事情就是把一句表达式自动地封装成一个闭包(closure)，<br>自动闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。<br>自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。延迟求值对于那些有副作用和高计算成本的代码来说是很有益处的，因为它使得你能控制代码的执行时机。例如：</p><pre class="line-numbers language-none"><code class="language-none">var customersInLine &#x3D; [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]print(customersInLine.count)&#x2F;&#x2F; 打印出“5”let customerProvider &#x3D; &#123; customersInLine.remove(at: 0) &#125;print(customersInLine.count)&#x2F;&#x2F; 打印出“5”print(&quot;Now serving \(customerProvider())!&quot;)&#x2F;&#x2F; Prints &quot;Now serving Chris!&quot;print(customersInLine.count)&#x2F;&#x2F; 打印出“4”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里联想到了系统 ?? 这个操作符，根据延迟求值的这个特性，猜测一下这个方法的具体实现。</p><pre class="line-numbers language-none"><code class="language-none">func ??&lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T) -&gt; T &#123;    switch optional &#123;    case .Some(let value):         return value    case .None:         return defaultValue()&#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们需要返回的时候，一般思路是需要对optional进行求值，如果optinal不为nil的话，我们完全可以避免这个求值的计算，即将求值计算推迟到optional 判定为nil 之后。</p><h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p><pre class="line-numbers language-none"><code class="language-none">func makeAdd(addNum amount: Int) -&gt; () -&gt; Int &#123;    var total &#x3D; 0    func add() -&gt; Int &#123;        total +&#x3D; amount        return total    &#125;    return add&#125;let addTen &#x3D; makeAdd(addNum: 10)addTen() &#x2F;&#x2F;10addTen() &#x2F;&#x2F; 20let answer &#x3D; addTen() print(answer) &#x2F;&#x2F; 30let addTenAnother &#x3D; makeAdd(addNum: 10)print(addTenAnother()) &#x2F;&#x2F; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码makeAdd函数返回的是一个 () -&gt; Int 内嵌函数类型也就是闭包的一种类型，是一个引用类型，然后创建了一个addTen函数类型对象，这个对象内部对total这个变量进行了值捕获，当这个函数类型对象消亡时，Swift也会为我们进行total这类的变量回收。</p><p>随便聊聊闭包，来总结一下：闭包是Swift里面的一个特别重要的概念，因为它，让swift的代码更加优雅，笔者目前也正在努力学习着，期待着有一天能写出非常优雅的代码。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019比赛总结</title>
      <link href="/2019/10/30/2019_match_summary/"/>
      <url>/2019/10/30/2019_match_summary/</url>
      
        <content type="html"><![CDATA[<p>伴随着移动应用赛的结束，终于可以开始好好沉淀自己的技术了！2019年，因为它，学到了很多东西，很久没有写博客了。想把这一切都记录下来。那就从这篇博客开始吧~</p><h3 id="杭州决赛（10-25-27）——-结束"><a href="#杭州决赛（10-25-27）——-结束" class="headerlink" title="杭州决赛（10.25-27）—— 结束"></a>杭州决赛（10.25-27）—— 结束</h3><p>比赛结束。从初赛到决赛，我们经历了大半年的时间。团队付出了很多，同时也收货了很多，我们拿到了三等奖。得到了Apple的奖励、认识了很多其他高校的同学……，收货了很多很多。这么长的比赛周期，发自内心的有点累，《行迹》这个作品，写了四个版本的代码。每一次推到重建都是在进步。作为队长，负责项目的全部程序任务，产品分析，鼓励团队成员，不能放弃。<br>在结束之际，有很多要写的吧。但是又不知道从哪里说起。我想，终于可以开始好好沉淀自己的技术啦。喜欢的iOS开发，终于有时间好好地去理解了。</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这充实的岁月，正是奋斗的最好年华 — 2018年总结</title>
      <link href="/2018/12/30/2018_summary/"/>
      <url>/2018/12/30/2018_summary/</url>
      
        <content type="html"><![CDATA[<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>梦想着远方，哪怕它遥远而一无所有，做一个向着光奔跑的程序员。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>大一下的时候，那时候喜欢上了玩吃鸡，很多很多次都借着别人的电脑玩吃鸡，五一那几天假期，和室友在寝室里面，不分白天黑夜的玩，还立下不吃鸡不睡觉的flag。过了五一假期，整个人都精神涣散，后来慢慢调整，慢慢淡出游戏，之后就没有借电脑玩游戏了。<br>大一期末考完高数，分了班，换了寝室，从爬6楼到只要爬4楼了。也换了室友，室友是自己选的（这个自由选择室友的分寝室方法真的很不错），志同道合的我们四个湖南人走到了一起。</p><h2 id="晚睡与早起"><a href="#晚睡与早起" class="headerlink" title="晚睡与早起"></a>晚睡与早起</h2><p>记得之前高中的时候晚上11点了，觉得已经很晚了。然后到了大学，经常性的12点甚至12点之后才睡。有些时候是玩手机到12点，有些时候是写代码到凌晨，有些时候是寝室交流到12点，不管是哪种，熬夜伤身体，不好。<br>关于早起，记得大一入党积极分子交谈的时候，很有底气的说：大学从来没有晚于7点30起来，到了大二下学期12月份，没课了，经常性的8-9点起来，甚至10-11点才起来。</p><h2 id="篮球与健身"><a href="#篮球与健身" class="headerlink" title="篮球与健身"></a>篮球与健身</h2><p>不知道从高一还是初三那一年开始，我喜欢上了科比，喜欢上了篮球，在高中三年，只要有空闲时间总会拿着球，喊着其他人一起去打球，似乎慢慢的这种爱好变成了一种习惯。但是到了大学，时间变多了，打球的次数却变少了，由于学习或者打球场地较远，或者时间不够，打球的次数也渐渐变少了。不过当自己拿起球的时候，那种感觉还是依然存在。<br>来大学前就想着，要把自己全身多余的肉炼成肌肉，在大二开始跑了35km之后，就去报了健身房，连续去了两次之后，跟很多人一样，就没去健身了。</p><h2 id="朋友圈与娱乐"><a href="#朋友圈与娱乐" class="headerlink" title="朋友圈与娱乐"></a>朋友圈与娱乐</h2><p>有一句是：你在青春热血的年纪，拿着手机，刷着微博，看着新闻，做着我八十岁能做的事，你要青春干什么。诚然，这句话反应了很多年轻人的现状，反思自己，不经常做这些事，看抖音也是看一些学习或者提升自己的短视频，在自己学习类了的时候，偶尔会拿出来做做八十岁能做的事。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="iOS开发"><a href="#iOS开发" class="headerlink" title="iOS开发"></a>iOS开发</h2><p>从小白终于到了入门阶段了，如果当初学长要我入门学的是OC语言，不是swift的话，可能会快一点，查了很多swift的资料，查出来很多很多OC的，前期不知道怎么办，进度慢。<br>目前能够自己解决掉大部分开发中遇到的问题，学会了如何解决问题，同时也在用swift重写工大助手，已经写了约70%的功能了，能够看懂OC代码了。<br>大一暑假 当初去写老来宝app的时候，由于要搬到江西去写，之后由于一些特殊情况就放弃了，其实不应该放弃的，这让队友一个人在写，导致最后没有写出来而没有拿到钱，我在那里可能也写不出，但是不应该放弃队友。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>大一下学期，报了蓝桥杯，在3月开学的第一个月里，自己在慢慢的摸索学习算法，蓝桥杯只拿了省三，不过对于初次比赛的我，很开心，那个时候以及知足了。由于三月分的算法学习，导致了4月1号打完蓝桥杯，4月份一整月都没做什么事，都在玩。<br>到了年底，期间把时间花在了iOS上面，水平还是不够，只会基本的dp 搜索等基础题目。</p><h2 id="数学与英语"><a href="#数学与英语" class="headerlink" title="数学与英语"></a>数学与英语</h2><p>本想着大一参加数学竞赛的，却无奈时间不够用， 没有准备数竞。英语四级是一个做的不好的地方，裸考了第一次 397分，到了12月份的这次，感觉又很悬了。</p><h2 id="大学课程成绩"><a href="#大学课程成绩" class="headerlink" title="大学课程成绩"></a>大学课程成绩</h2><p>大一一年绩点3.7，班级排名第一，年级好像是12名。一等奖学金。对于一个喜欢代码，不喜欢其他课程的程序员来讲，平均85+ 也有点难度。</p><h1 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h1><p>记得大一来的时候，去面试学习部，被刷了，当时很郁闷。后来反思，自己能力不足，有问题。经过这一年多的努力，担任班上学习委员，18级新生小班助。能力有所提高。学习部应该会收我了！！！</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>在大学，作为学计算机的程序员，应该耐得住寂寞，心应该静下来。如果学计算机的不能够静心的话，那应该在这一领域上走不远。</p><h1 id="总结与展望2019"><a href="#总结与展望2019" class="headerlink" title="总结与展望2019"></a>总结与展望2019</h1><p>2018这一年，走过许多坎坎坷坷，让自己明白：什么事情都要全力以赴，不要管结果怎么样，尽力了，不后悔就是最好的。2018 这年已经过去了，已经翻篇了，人生很重要的2019 和2020 就要来了，希望接下来的两年： 我自己所做的，都是因为自己想做，自己喜欢。那些不足的地方，自己应该好好改进。希望能在大二结束的时候拿到实习offer。加油吧！2019！！！ 热爱生活，专注能力提升，追逐自己心中那份光！</p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>getchar()用法</title>
      <link href="/2018/12/05/getchar/"/>
      <url>/2018/12/05/getchar/</url>
      
        <content type="html"><![CDATA[<h1 id="c语言getchar-字符串题坑-的用法："><a href="#c语言getchar-字符串题坑-的用法：" class="headerlink" title="c语言getchar(字符串题坑)的用法："></a>c语言getchar(字符串题坑)的用法：</h1><p>1.从缓冲区读走一个字符，相当于清除缓冲区</p><p>2.前面的scanf()在读取输入时会在缓冲区中留下一个字符’\n’（输入完s[i]的值后按回车键所致），所以如果不在此加一个getchar()把这个回车符取走的话，gets(）就不会等待从键盘键入字符，而是会直接取走这个“无用的”回车符，从而导致读取有误</p><p>3.getchar()是在输入缓冲区顺序读入一个字符(包括空格、回车和Tab)<br>getchar()使用不方便,解决方法：<br>（1）使用下面的语句清除回车：<br>while(getchar()!=’\n’);<br>（2）用getche()或getch()代替getchar()，其作用是从键盘读入一个字符（不用按回车），注意要<br>包含头文件&lt;conio.h&gt;</p><p>4.PS：看的其他人，讲的很好，就搬了过来<br>getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数<br>据的话不用输入它就可以直接读取了，第一次getchar()时，确实需要人工的输入，但是如果你输了多<br>个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。<br>实际上是 输入设备-&gt;内存缓冲区-&gt;程序getchar<br>你按的键是放进缓冲区了,然后供程序getchar<br>你有没有试过按住很多键然后等一会儿会滴滴滴滴响,就是缓冲区满了,你后头按的键没有存进缓冲区.键盘输入的字符都存到缓冲区内,一旦键入回车,getchar就进入缓冲区读取字符,一次只返回第一个字符作为getchar函数的值,如果有循环或足够多的getchar语句,就会依次读出缓冲区内的所有字符直到’\n’.要理解这一点,之所以你输入的一系列字符被依次读出来,是因为循环的作用使得反复利用getchar在缓冲区里读取字符,而不是getchar可以读取多个字符,事实上getchar每次只能读取一个字符.如果需要取消’\n’的影响,可以用getchar();来清除,这里getchar();只是取得了’\n’但是并没有赋给任何字符变量,所以不会有影响,相当于清除了这个字符.还要注意的是这里你在键盘上输入ssss看到的回显正是来自于getchar的作用,如果用getch就看不到你输入了什么.<br>综上所述：回车键顶替了输入字符的第一个字符，如果不添加getchar()；就会输出错误。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于刷题入门（冒泡、选择排序）总结</title>
      <link href="/2018/12/05/acm_4/"/>
      <url>/2018/12/05/acm_4/</url>
      
        <content type="html"><![CDATA[<h3 id="简单题刷了一定数量以后，肯定会遇到排序的一些题要进行排序才能解决，排序先从这两种简单的排序掌握，在去接触快速排序和归并排序。"><a href="#简单题刷了一定数量以后，肯定会遇到排序的一些题要进行排序才能解决，排序先从这两种简单的排序掌握，在去接触快速排序和归并排序。" class="headerlink" title="简单题刷了一定数量以后，肯定会遇到排序的一些题要进行排序才能解决，排序先从这两种简单的排序掌握，在去接触快速排序和归并排序。"></a>简单题刷了一定数量以后，肯定会遇到排序的一些题要进行排序才能解决，排序先从这两种简单的排序掌握，在去接触快速排序和归并排序。</h3><h3 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h3><p>冒泡排序：顾名思义就是 小的数往上面冒，大的数往下沉（升序）。当然也可以反过来进行（降序）。</p><p>冒泡排序是常用的一种排序方法，其基本方法就是逐次比较。即一次比较两个数，若它们的顺序错误，则它们交换；重复进行，直到没有需要交换为止。</p><p>以升序为例：</p><p>            1、比较相邻数字的大小，若第一个数比第二个数大，则相互交换；<br>           <br>            2、对每一对相邻的数作相同的工作，那么最后的数应该是最大的数；<br>           <br>            3、针对所有数（除了最后一个）重复上述步骤，直到没有任何一对数字需要比较为止。<br>           <br>            需要注意的是，第3条中所谓的“最后一个”是指前几步中已经处理过的最大的数，而不是整个数列的最后一个数<br>           <br>            例如，将下列数列用冒泡排序法从小到大重新排列;<br>           <br>                                  48 37 64 96 75 12 26 48<br>                                 <br>                                           每次排序后数列的变化如下：<br>                                           <br>                                                    第一次排序：37 48 64 75 12 26 48 96   第一次排序之后 最大的已经到了最后面（最下面）<br>                                                    <br>                                                             第二次排序：37 48 64 12 26 48 75 96  第二次排序之后，第二大的到了倒数第二个位置 （往下也是这样）<br>                                                             <br>                                                                      第三次排序：37 48 12 26 48 64 75 96 ……<br>                                                                      <br>                                                                               第四次排序：37 12 26 48 48 64 75 96 ……<br>                                                                               <br>                                                                                                    :<br>                                                                                                    <br>                                                                                                                         :<br>                                                                                                                        <br>                                                                                                                                              :<br>                                                                                                                                             <br>                                                                                                                                                        经过一系列过程，最终数列次序为：12 26 37 48 48 64 75 96.<br>                                                                                                                                                       <br>                                                                                                                                                        冒泡排序原理弄清之后，接下来就是代码实现了：<br>                                                                                                                                                       <br>                                                                                                                                                        <pre class="line-numbers language-none"><code class="language-none">                                                                                                                                                        &#x2F;&#x2F;冒泡排序                                                                                                                                                        &#x2F;&#x2F;设数组a 有n个元素                                                                                                                                                        int t;                                                                                                                                                        for(i&#x3D;0;i&lt;n-1;i++)&#x2F;&#x2F;n个数的数列总共扫描n-1次                                                                                                                                                        &#123;                                                                                                                                                        for(j&#x3D;0;j&lt;n-i-1;j++)&#x2F;&#x2F;每一趟扫描到a[n-i-2]与a[n-i-1]比较为止结束                                                                                                                                                        &#123;                                                                                                                                                        if(a[j]&gt;a[j+1])&#x2F;&#x2F;后一位数比前一位数小的话，就交换两个数的位置（升序）                                                                                                                                                        &#123;                                                                                                                                                        t&#x3D;a[j+1];                                                                                                                                                        a[j+1]&#x3D;a[j];                                                                                                                                                        a[j]&#x3D;t;                                                                                                                                                        &#125;                                                                                                                                                        &#125;                                                                                                                                                        &#125;                                                                                                                                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>                                                                                                                                                       <br>                                                                                                                                                        <img src="https://upload-images.jianshu.io/upload_images/13179799-d120a1423224aac0.gif?imageMogr2/auto-orient/strip"><br>                                                                                                                                                       <br>                                                                                                                                                        ### 选择排序：<br>                                                                                                                                                       <br>                                                                                                                                                        选择法排序是相对好理解的排序算法。假设要对含有n个数的序列进行升序排列，算法步骤是：<br>                                                                                                                                                       <br>                                                                                                                                                           1、从数组存放的n个数中找出最小数的下标（算法见下面的“求最值”），然后将最小数与第1个数交换位置；<br>                                                                                                                                                           <br>                                                                                                                                                              2、除第1个数以外，再从其余n-1个数中找出最小数（即n个数中的次小数）的下标，将此数与第2个数交换位置；<br>                                                                                                                                                              <br>                                                                                                                                                                 3、重复步骤1  n-1趟，即可完成所求。<br>                                                                                                                                                                 <br>                                                                                                                                                                 <pre class="line-numbers language-none"><code class="language-none">                                                                                                                                                                 &#x2F;&#x2F;选择排序                                                                                                                                                                 &#x2F;&#x2F;设数组a 为待排序数组                                                                                                                                                                 int k,i,j;                                                                                                                                                                 for(i&#x3D;0;i&lt;n-1;i++)         &#x2F;*处理n-1趟*&#x2F;                                                                                                                                                                 &#123;                                                                                                                                                                 k &#x3D; i;      &#x2F;*总是假设此趟处理的第一个（即全部数的第i个）数最小，k记录其下标*&#x2F;                                                                                                                                                                 for(j&#x3D;i+1;j&lt;n;j++)                                                                                                                                                                 &#123;                                                                                                                                                                 if(a[j] &lt; a[k])                                                                                                                                                                 k &#x3D; j;                                                                                                                                                                  &#125;                                                                                                                                                                 if (k !&#x3D; i)                                                                                                                                                                 &#123;                                                                                                                                                                  t &#x3D; a[i];                                                                                                                                                                  a[i] &#x3D; a[k];                                                                                                                                                                  a[k] &#x3D; t;                                                                                                                                                                  &#125;                                                                                                                                                                 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>                                                                                                                                                                 <br>                                                                                                                                                                 <img src="https://upload-images.jianshu.io/upload_images/13179799-d114702e2a48e4cb.gif?imageMogr2/auto-orient/strip"><br>                                                                                                                                                                 <br>                                                                                                                                                                 本文详细举例讲了冒泡排序，在刷题前期中 会冒泡排序了，基本上就很少用到选择排序，所以对于选择排序没有详细讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于刷题入门(时间和空间复杂度)的总结</title>
      <link href="/2018/12/05/acm_3/"/>
      <url>/2018/12/05/acm_3/</url>
      
        <content type="html"><![CDATA[<h2 id="时间和空间复杂度"><a href="#时间和空间复杂度" class="headerlink" title="时间和空间复杂度"></a>时间和空间复杂度</h2><p>在刷题过程中会遇到一些超时的现象，这就说明你的算法不符合题目要求的运行时间，称为超时。</p><p>时间复杂度：目前通俗来讲就是程序在完成后台测试数据（每组数据对应一个时间，所有时间都符合才可以）要花的时间，如果这个时间超过题目要求的时间（通常是1000ms）就会超时。它的具体定义以及公式计算等等会在数据结构这本书上出现。</p><p>空间复杂度：通俗来讲就是程序所占的内存。刷题中，这种情况很少出现这个超出限制。</p><h3 id="Time-Limited-Exceed（超时）"><a href="#Time-Limited-Exceed（超时）" class="headerlink" title="Time Limited Exceed（超时）"></a>Time Limited Exceed（超时）</h3><p>简称TLE。通常需要进行算法优化来降低时间复杂度，加快代码运行的时间。 <br>常见的TLE有以下几种情况：</p><p>1、程序中出现无法终止的死循环<br>2、读取输入流和输出流的时间太长。（C++的输入输出中，cin和cout没有scanf和printf快，不要问我是怎么知道的，我都已经在输入输出上载过无数跟头了….建议同学们养成用scanf和printf的好习惯）<br>3、时间复杂度大，常常是多层循环或者深递归导致。建议大家能不用循环的时候，就不用循环，因为循环费时。</p><p>如何判断自己的程序是否会超时：  首先看题目数据的大小， 会给一个数据范围，比如0&lt;N &lt;1000， 接下来看你的程序的代码的语句一共运行多少次， 基本上就是看 循环的层数（一般是看有多少个for嵌套或者while）。N为上面那个范围，要考虑极限数据 就是 N = 1000的情况， 三个for嵌套 就是 1000的三次方 等于10亿 对于这个数量级程序就会超时。 程序执行语句次数一般控制在10^7 到10^8以下 就不会超时，这个是因为计算机每秒可以运行大概10^8条语句。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于刷题入门(简单题操作)的总结</title>
      <link href="/2018/12/05/acm_2/"/>
      <url>/2018/12/05/acm_2/</url>
      
        <content type="html"><![CDATA[<h2 id="Cone-总结"><a href="#Cone-总结" class="headerlink" title="Cone 总结"></a>Cone 总结</h2><p>一、判断一个数的奇偶性</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 判断奇偶性 只需要对2取模即可，模为1位奇数，反之为偶int a;if(a%2&#x3D;&#x3D;1)&#123;printf(&quot;a为奇数&quot;)；&#125;else&#123;printf(&quot;a为偶数&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-c4bfc98579f31a15.gif?imageMogr2/auto-orient/strip"> </p><p>二、判断闰年</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1、能整除4且不能整除100  2、能整除400 二者成立一个即可int y;if((y%400&#x3D;&#x3D;0)||(y%4&#x3D;&#x3D;0&amp;&amp;y%100!&#x3D;0))&#123;printf(&quot;这年为闰年&quot;);&#125;else&#123;printf(&quot;这年为平年&quot;)；&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-a80c3adb3d79fe6a.gif?imageMogr2/auto-orient/strip"> </p><p>三、判断三边是否能够构成一个三角形</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;在已知三边都大于0的情况下 任意两边之和大于第三边即可int a,b,c;if((a+b&gt;c)&amp;&amp;(a+c&gt;b)&amp;&amp;(c+b&gt;a))&#123;printf(&quot;a,b,c三边可以构成三角形&quot;);&#125;else&#123;printf(&quot;a,b,c三边无法构成三角形&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-15544cad285d0b89.gif?imageMogr2/auto-orient/strip"> </p><p>四、关于三个数比较大小并排序</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 利用if判断是否需要交换值 int a,b,c,t;if(a&gt;b) &#x2F;&#x2F;保证a&lt;&#x3D;b&#123;t&#x3D;a;a&#x3D;b;b&#x3D;t;&#125;if(a&gt;c) &#x2F;&#x2F;保证a&lt;&#x3D;c，这样，a就最小了&#123;t&#x3D;a;a&#x3D;c;c&#x3D;t;&#125;if(b&gt;c) &#x2F;&#x2F;对比a大的两个字符，保证b&lt;&#x3D;c&#123;t&#x3D;b;b&#x3D;c;c&#x3D;t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-07ec189cf94148b5.gif?imageMogr2/auto-orient/strip"> </p><p>五、关于求一个数中各个位数上的数字算法：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;这里以三位数为例int i; &#x2F;&#x2F; i 为三位数a&#x3D;i&#x2F;100;b&#x3D;(i-a*100)&#x2F;10;c&#x3D;i%10;&#x2F;&#x2F; a为百位上的数 b为十位上的数 c为个位上的数；&#x2F;&#x2F;例如 i&#x3D;123  a&#x3D;1 b&#x3D;2 c&#x3D;3; 看懂运算符 &#x2F; 的用法就很好掌握这个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-775044f577b7ea88.gif?imageMogr2/auto-orient/strip"> </p><h3 id="关于简单数学知识的总结："><a href="#关于简单数学知识的总结：" class="headerlink" title="关于简单数学知识的总结："></a>关于简单数学知识的总结：</h3><p>一、两点间的距离公式</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 初中知识，就不解释了 坐标（x1,y1）(x2,y2)double x1,y1,x2,y2;double d &#x3D; 0;d &#x3D; sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#x2F;&#x2F;d 为距离<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-49cdff256108af12.gif?imageMogr2/auto-orient/strip" alt="image.gif"> </p><p>二、球的体积公式</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 好像也是初中知识，设P &#x3D; π ;double V,r;V&#x3D;4*P*(r*r*r)&#x2F;3;&#x2F;&#x2F;V为体积<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-129e92ca80453544.gif?imageMogr2/auto-orient/strip"> </p><p>三、数列求和公式</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;此处为等差数列求和 一 1，2，3，4，5 ………… t 为例int sum&#x3D;0;int t,n:if(t%2&#x3D;&#x3D;0)&#123;n&#x3D;t&#x2F;2;t&#x3D;t+1;&#125;else&#123;n&#x3D;(t+1)&#x2F;2;&#125;sum &#x3D; t*n;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13179799-b9f7d2966d335c27.gif?imageMogr2/auto-orient/strip"> </p><h3 id="最后一些小坑坑洼洼的总结："><a href="#最后一些小坑坑洼洼的总结：" class="headerlink" title="最后一些小坑坑洼洼的总结："></a>最后一些小坑坑洼洼的总结：</h3><p>1、要看清楚题目，题目给出的数是整数还是浮点数。</p><p>2、如果题目给出一个范围区间的两个数m,n，题目没有说明m&lt;n 或者n&lt;m，就需要判断m，n的大小关系。</p><p>3、小数点的保留要注意。（%.alf）a 为要保留的位数小数点 例如%.2lf 保留两位小数。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于输入、输出的总结</title>
      <link href="/2018/12/05/acm_1/"/>
      <url>/2018/12/05/acm_1/</url>
      
        <content type="html"><![CDATA[<h1 id="Cone"><a href="#Cone" class="headerlink" title="Cone"></a>Cone</h1><p>写博客是一个输出的过程，对于自己学习的一个总结，从这篇博客开始，以后坚持写博客，把踩过的坑以及总结记录下来，以后自己还可以慢慢看 回忆大学四年学习历程。</p><p>总结一下踩过的坑：第一次开始接触杭电1000题，C语言语法才掌握小部分，就开始刷题，1000题错了20多次，最后还是百度到的多组输入数据才过。</p><p>对于读题：那时候以为题目中的 A B N这种字母， 我的程序变量就要定义为A B N这种，这个显然是错的，变量是随便自己定义的。定义为 a,b都可以 例如 杭电1000题 定义为 int a,b; 然后使用a,b都可以。</p><p>对于输入和输出： 输入时要从键盘输入，输出通俗就打印结果在运行窗口上面，每输入一组数据 就打印一组结果，输入输出刚开始看也一知半解的。</p><p>Sample Input</p><pre class="line-numbers language-none"><code class="language-none">1 510 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Sample Output</p><pre class="line-numbers language-none"><code class="language-none">630<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如这种，先输入1 和 5 在打印6 然后输入10 20 在打印30 。<br>对于AC：oj系统后台很多测试数据，你的程序要通过全部的测试数据才能AC </p><p>入门：杭电1000 A+B<br>题目： 要求输入多组数据到程序结束。<br>这种多组数据输入需要用到!=EOF 或者~ 这种格式 例如：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;!&#x3D;EOF 情况int a,b;while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!&#x3D;EOF)&#123;&#125;&#x2F;&#x2F; ~ 情况while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两种方法可以达到同一效果。还有其他方法，这里就不列举。掌握这两种情况 对于以后这种多组数据输入题目就可以处理解决。<br>输出：要求每一行输出一个测试数据答案。即加上一个换行符(‘\n’)就可以轻松解决</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;假设sum 为输出结果printf(&quot;%d\n&quot;,sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="输入情形"><a href="#输入情形" class="headerlink" title="输入情形"></a>输入情形</h1><h3 id="一、要求输入N组测试数据-："><a href="#一、要求输入N组测试数据-：" class="headerlink" title="一、要求输入N组测试数据  ："></a>一、要求输入N组测试数据  ：</h3><p>Input<br>Input contains an integer N in the first line, and then N lines follow. Each line consists of a pair of integers a and b, separated by a space, one pair of integers per line. </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这种情况 要用到循环， 我用的是while 这种循环int N;while(N--)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、要求输入数据到为0结束："><a href="#二、要求输入数据到为0结束：" class="headerlink" title="二、要求输入数据到为0结束："></a>二、要求输入数据到为0结束：</h3><p>Input<br>Input contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed. </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;这种为0的情况处理，我用的跳出循环语句：breakint a,b;while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))&#123;if(a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0)&#123;break;   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是两个数为0的情况， 一个数为0的情况 去掉一个 b == 0 即可，多个数据为0 也是同样处理 </p><h3 id="三、要求输入多组数据，输出结果中一空行隔开："><a href="#三、要求输入多组数据，输出结果中一空行隔开：" class="headerlink" title="三、要求输入多组数据，输出结果中一空行隔开："></a>三、要求输入多组数据，输出结果中一空行隔开：</h3><p>Input<br>The input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line.<br>Output<br>For each pair of input integers a and b you should output the sum of a and b, and followed by a blank line. </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 多加一个\n即可解决&#x2F;&#x2F;假设sum为输出结果printf(&quot;%d\n\n&quot;,sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、要求输入N组数据，每个输出结果之间以空行隔开。注意是输出结果之间，最后一组数据不要空行"><a href="#四、要求输入N组数据，每个输出结果之间以空行隔开。注意是输出结果之间，最后一组数据不要空行" class="headerlink" title="四、要求输入N组数据，每个输出结果之间以空行隔开。注意是输出结果之间，最后一组数据不要空行"></a>四、要求输入N组数据，每个输出结果之间以空行隔开。注意是输出结果之间，最后一组数据不要空行</h3><p>Input<br>Input contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line. </p><p>Output<br>For each group of input integers you should output their sum in one line, and you must note that there is a blank line between outputs. </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;采用if判断int t;scanf(&quot;%d&quot;,&amp;t);while(t--)&#123;if(t!&#x3D;0)   &#123;printf(&quot;\n&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最后oj系统的提交结果出现的情况："><a href="#最后oj系统的提交结果出现的情况：" class="headerlink" title="最后oj系统的提交结果出现的情况："></a>最后oj系统的提交结果出现的情况：</h2><h3 id="Accepted-正确"><a href="#Accepted-正确" class="headerlink" title="Accepted (正确)"></a>Accepted (正确)</h3><p>当你在某一ACM在线测评系统上提交了你的代码后，如果你得到了一个Accepted，简称AC，恭喜你，通过了这道题，你的代码是正确的。除了Accepted之外的所有结果，都是不符合要求的。</p><h3 id="Compile-Error（编译错误）"><a href="#Compile-Error（编译错误）" class="headerlink" title="Compile Error（编译错误）"></a>Compile Error（编译错误）</h3><p>简称CE。通常是指语法错误，这是最最简单的错误了，因为你完全可以在提交之前，在本地的编译器上测试出来，然后改正。</p><h3 id="Wrong-Answer（错误）"><a href="#Wrong-Answer（错误）" class="headerlink" title="Wrong Answer（错误）"></a>Wrong Answer（错误）</h3><p>简称WA。很多ACM新手们，在千辛万苦写好一份代码并且自认为是正确的，但是提交之后却得到了Wrong Answer的结果，他们百思不得其解，其实，OJ的后台有很多组测试数据，就算你的代码可以通过样例，但并不代表可以通过后台的所有数据，只要你有一组数据输出与测试输出不一样，你就无法AC。所以建议同学们，可以自己脑补一些特殊数据，看看是否能够得到正确的结果。除此之外，还要再次认真读题，很多时候Wrong Answer都是因为没有正确理解题目的意思。</p><h3 id="Presentation-Error-格式错误"><a href="#Presentation-Error-格式错误" class="headerlink" title="Presentation Error(格式错误)"></a>Presentation Error(格式错误)</h3><p>简称PE。这种错误还是比较容易发现并改正的，通常产生的原因是由于你的代码输出的格式与题目要求的不一致。 </p><p>常见的PE有以下几种：<br>1、大小写错误<br>2、行末不应该有空格<br>3、分号 冒号 逗号等中英文标点符号傻傻分不清<br>4、换行和空格乱用</p><h3 id="Time-Limited-Exceed（超时）"><a href="#Time-Limited-Exceed（超时）" class="headerlink" title="Time Limited Exceed（超时）"></a>Time Limited Exceed（超时）</h3><p>简称TLE。通常需要进行算法优化来降低时间复杂度，加快代码运行的时间。<br>常见的TLE有以下几种情况：<br>1、程序中出现无法终止的死循环<br>2、读取输入流和输出流的时间太长。（C++的输入输出中，cin和cout没有scanf和printf快，不要问我是怎么知道的，我都已经在输入输出上载过无数跟头了….建议同学们养成用scanf和printf的好习惯）<br>3、时间复杂度大，常常是多层循环或者深递归导致。建议大家能不用循环的时候，就不用循环，因为循环费时。</p><h3 id="Runtime-Error（运行错误）"><a href="#Runtime-Error（运行错误）" class="headerlink" title="Runtime Error（运行错误）"></a>Runtime Error（运行错误）</h3><p>简称RE。这种错误也是好避免的。<br>常见的RE有以下几种：<br>1、数组开得太小了，导致访问到了不该访问的内存区域<br>2、发生除零错误<br>3、大数组定义在函数内，导致程序栈区耗尽<br>4、指针用错了，导致访问到不该访问的内存区域<br>5、程序抛出了未接受的异常</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统 利用github+hexo 搭建自己的Blog</title>
      <link href="/2018/12/04/FirstBlog/"/>
      <url>/2018/12/04/FirstBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="1-Git"><a href="#1-Git" class="headerlink" title="1.Git"></a>1.Git</h2><p>用来将本地Hexo内容提交到Github上。Xcode自带Git。</p><h2 id="2-Node-js"><a href="#2-Node-js" class="headerlink" title="2.Node.js"></a>2.Node.js</h2><p>用来生成静态页面。<a href="https://nodejs.org/en/download/">Node.js官网</a>。 下载下图红色箭头所指向的文件！<img src="https://upload-images.jianshu.io/upload_images/13179799-2bf72161dcd8dfe7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/13179799-ebbfca5e3b697d2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"> 最后一路按照即可！</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>打开终端执行以下命令</p><blockquote><p>$ sudo npm install -g hexo  </p></blockquote><p>执行该命令后hexo即安装完成</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在桌面创建一个名为hexo的文件夹 然后终端进入到该文件夹执行如下命令：</p><blockquote><p>$ hexo init</p></blockquote><p>然后执行如下命令打开hexo 服务器</p><blockquote><p>$ hexo s</p></blockquote><p>打开<a href="http://localhost:4000/">http://localhost:4000</a> , 能看到如下界面 <img src="https://upload-images.jianshu.io/upload_images/13179799-e814287874919b62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>本地搭建完成，下面关联Github</p><h1 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h1><h2 id="1-登录Github"><a href="#1-登录Github" class="headerlink" title="1.登录Github"></a>1.登录Github</h2><p>登陆你的GitHub，新建仓库，名为用户名.github.io固定写法。如下图所示：<img src="https://upload-images.jianshu.io/upload_images/13179799-2a63e9ea44cd6d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>本地内容如下:<img src="https://upload-images.jianshu.io/upload_images/13179799-457d98575321f4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br> 终端cd到本地 hexo 文件夹下，打开文件夹下 _config.yml 文件，终端输入命令：</p><blockquote><p>$ vim _config.yml</p></blockquote><p>打开之后往下滑到最后修改成如下样子：<img src="https://upload-images.jianshu.io/upload_images/13179799-86b622bab7259975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>把红框内容改成自己的github用户名即可</p><p>接下来执行如下命令： </p><blockquote><p>$ hexo g </p></blockquote><p>若出现找不到博客错误则执行:</p><blockquote><p>$ npm install hexo –save</p></blockquote><p>在执行如下命令</p><blockquote><p>$ hexo d</p></blockquote><p>若出现无法连接git或找不到git，则执行如下命令来安装：</p><blockquote><p> $ npm install hexo-deployer-git –save  </p></blockquote><p>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p><blockquote><p>Username for ‘<a href="https://github.com&/#39;">https://github.com&#39;</a>:<br>  Password for ‘<a href="https://github.com&/#39;">https://github.com&#39;</a>:</p></blockquote><p>hexo d 命令成功后 打开：<a href="http://zhangchione.github.io/">http://zhangchione.github.io</a> 将zhangchione改成你的 用户名即可。和之前打开的一样。</p><p>本地和git关联成功 </p><h2 id="属于自己的博客搭建成功！！"><a href="#属于自己的博客搭建成功！！" class="headerlink" title="属于自己的博客搭建成功！！"></a>属于自己的博客搭建成功！！</h2>]]></content>
      
      
      <categories>
          
          <category> 网页搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/22/hello-world/"/>
      <url>/2018/06/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
